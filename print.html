<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Index</a></li><li class="chapter-item expanded affix "><a href="docs/Introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="docs/Contributions.html">Contribution guide</a></li><li class="chapter-item expanded affix "><a href="docs/Prerequisites.html">Prerequisites</a></li><li class="chapter-item expanded affix "><li class="part-title">Lesson 1: Zephyr Setup</li><li class="chapter-item expanded "><a href="docs/zephyr-setup/install/installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/zephyr-setup/install/mac-os.html"><strong aria-hidden="true">1.1.</strong> Installation MacOS</a></li><li class="chapter-item expanded "><a href="docs/zephyr-setup/install/windows.html"><strong aria-hidden="true">1.2.</strong> Installation Windows</a></li><li class="chapter-item expanded "><a href="docs/zephyr-setup/install/linux.html"><strong aria-hidden="true">1.3.</strong> Installation Linux</a></li></ol></li><li class="chapter-item expanded "><a href="docs/zephyr-setup/setup/setup.html"><strong aria-hidden="true">2.</strong> Workspace Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/zephyr-setup/setup/mac-os.html"><strong aria-hidden="true">2.1.</strong> Workspace Setup MacOS</a></li><li class="chapter-item expanded "><a href="docs/zephyr-setup/setup/windows.html"><strong aria-hidden="true">2.2.</strong> Workspace Setup Windows</a></li><li class="chapter-item expanded "><a href="docs/zephyr-setup/setup/linux.html"><strong aria-hidden="true">2.3.</strong> Workspace Setup Linux</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 2: Introduction</li><li class="chapter-item expanded "><a href="docs/introduction/rtos-basics.html"><strong aria-hidden="true">3.</strong> RTOS basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/introduction/zephyr-structure.html"><strong aria-hidden="true">3.1.</strong> Zephyr basics</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 3: Threads</li><li class="chapter-item expanded "><a href="docs/threads/introduction.html"><strong aria-hidden="true">4.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/threads/commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/threads/kconfig.html"><strong aria-hidden="true">4.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/threads/exercise.html"><strong aria-hidden="true">4.3.</strong> Exercise</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 4: GPIO</li><li class="chapter-item expanded "><a href="docs/gpio/introduction.html"><strong aria-hidden="true">5.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/gpio/commands.html"><strong aria-hidden="true">5.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/gpio/kconfig.html"><strong aria-hidden="true">5.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/gpio/exercise.html"><strong aria-hidden="true">5.3.</strong> Exercise</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 5: Scheduling</li><li class="chapter-item expanded "><a href="docs/scheduling/introduction.html"><strong aria-hidden="true">6.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/scheduling/commands.html"><strong aria-hidden="true">6.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/scheduling/kconfig.html"><strong aria-hidden="true">6.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/scheduling/exercise.html"><strong aria-hidden="true">6.3.</strong> Exercise</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 6: Debugging</li><li class="chapter-item expanded "><a href="docs/debugging/introduction.html"><strong aria-hidden="true">7.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/debugging/commands.html"><strong aria-hidden="true">7.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/debugging/kconfig.html"><strong aria-hidden="true">7.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/debugging/exercise.html"><strong aria-hidden="true">7.3.</strong> Exercise</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 7: Interrupts</li><li class="chapter-item expanded "><a href="docs/interrupts/introduction.html"><strong aria-hidden="true">8.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/interrupts/commands.html"><strong aria-hidden="true">8.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/interrupts/kconfig.html"><strong aria-hidden="true">8.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/interrupts/exercise.html"><strong aria-hidden="true">8.3.</strong> Exercise</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 8: Mutexes</li><li class="chapter-item expanded "><a href="docs/lesson08/introduction.html"><strong aria-hidden="true">9.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/lesson08/commands.html"><strong aria-hidden="true">9.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/lesson08/kconfig.html"><strong aria-hidden="true">9.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/lesson08/exercise.html"><strong aria-hidden="true">9.3.</strong> Exercise</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 9: Semaphores</li><li class="chapter-item expanded "><a href="docs/lesson09/introduction.html"><strong aria-hidden="true">10.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/lesson09/commands.html"><strong aria-hidden="true">10.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/lesson09/kconfig.html"><strong aria-hidden="true">10.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/lesson09/exercise.html"><strong aria-hidden="true">10.3.</strong> Exercise</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 10: Logging</li><li class="chapter-item expanded "><a href="docs/logging/introduction.html"><strong aria-hidden="true">11.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/logging/commands.html"><strong aria-hidden="true">11.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/logging/kconfig.html"><strong aria-hidden="true">11.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/logging/exercise.html"><strong aria-hidden="true">11.3.</strong> Exercise</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 11: Networking</li><li class="chapter-item expanded "><a href="docs/networking/introduction.html"><strong aria-hidden="true">12.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/networking/commands.html"><strong aria-hidden="true">12.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/networking/kconfig.html"><strong aria-hidden="true">12.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/networking/exercise.html"><strong aria-hidden="true">12.3.</strong> Exercise</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Lesson 12: Timers</li><li class="chapter-item expanded "><a href="docs/timers/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/timers/commands.html"><strong aria-hidden="true">13.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="docs/timers/kconfig.html"><strong aria-hidden="true">13.2.</strong> Kconfig</a></li><li class="chapter-item expanded "><a href="docs/timers/exercise.html"><strong aria-hidden="true">13.3.</strong> Exercise</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="zephyr-tutorial-for-beginners"><a class="header" href="#zephyr-tutorial-for-beginners">Zephyr: Tutorial for Beginners</a></h1>
<p>This repository contains a step-by-step guide that teaches you how to use Zephyr RTOS. It assumes:</p>
<ul>
<li>no previous experience with RTOS</li>
<li>basic embedded electronics knowledge (GPIO, Timers, Interrupt,...)</li>
<li>knowledge of C</li>
</ul>
<p>Each lesson builds on the previous one. Most lessons end with exercises (with solutions!) that allow you to test your knowledge to make sure you understand everything that is covered.</p>
<p>This tutorial is under active development, if you want to participate - please read the <a href="docs/Contributions.html">Contribution guide</a>.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<p><strong><a href="docs/Introduction.html">Introduction</a></strong></p>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p><strong><a href="docs/Contributions.html">Contribution guide</a></strong></p>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p><strong><a href="docs/Prerequisites.html">Prerequisites</a></strong></p>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>Lesson 1: Zephyr Setup</strong> </p>
<ul>
<li><input disabled="" type="checkbox"/>
1.1 Installation
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="docs/zephyr-setup/install/mac-os.html">MacOS</a></li>
<li><input disabled="" type="checkbox"/>
<a href="docs/zephyr-setup/install/windows.html">Windows</a></li>
<li><input disabled="" type="checkbox"/>
<a href="docs/zephyr-setup/install/linux.html">Linux</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
1.2 Basic Workspace Setup
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="docs/zephyr-setup/setup/mac-os.html">MacOS</a></li>
<li><input disabled="" type="checkbox"/>
<a href="docs/zephyr-setup/setup/windows.html">Windows</a></li>
<li><input disabled="" type="checkbox"/>
<a href="docs/zephyr-setup/setup/linux.html">Linux</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p><strong>Lesson 2: Introduction</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
2.1 <a href="docs/introduction/rtos-basics.html">RTOS basics</a></li>
<li><input disabled="" type="checkbox" checked=""/>
2.2 <a href="docs/introduction/zephyr-structure.html">Zephyr structure</a></li>
<li><input disabled="" type="checkbox" checked=""/>
2.3 <a href="docs/introduction/tutorial-structure.html">Tutorial structure</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p><strong>Lesson 3: Threads</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
3.1 <a href="docs/threads/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox" checked=""/>
3.2 <a href="docs/threads/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox" checked=""/>
3.3 <a href="docs/threads/kconfig.html">Kconfig</a></li>
<li><input disabled="" type="checkbox" checked=""/>
3.4 <a href="docs/threads/exercise.html">Exercise</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p><strong>Lesson 4: GPIO</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
4.1 <a href="docs/gpio/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox" checked=""/>
4.2 <a href="docs/gpio/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox" checked=""/>
4.3 <a href="docs/gpio/kconfig.html">Kconfig</a></li>
<li><input disabled="" type="checkbox" checked=""/>
4.4 <a href="docs/gpio/exercise.html">Exercise</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p><strong>Lesson 5: Scheduling</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
5.1 <a href="docs/scheduling/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox" checked=""/>
5.2 <a href="docs/scheduling/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox" checked=""/>
5.3 <a href="docs/scheduling/kconfig.html">Kconfig</a></li>
<li><input disabled="" type="checkbox" checked=""/>
5.4 <a href="docs/scheduling/exercise.html">Exercise</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>Lesson 6: Debugging</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
6.1 <a href="docs/debugging/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox" checked=""/>
6.2 <a href="docs/debugging/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox" checked=""/>
6.3 <a href="docs/debugging/kconfig.html">Kconfig</a></li>
<li><input disabled="" type="checkbox" checked=""/>
6.4 <a href="docs/debugging/exercise.html">Exercise</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p><strong>Lesson 7: Interrupts</strong> </p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
7.1 <a href="docs/interrupts/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox" checked=""/>
7.2 <a href="docs/interrupts/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox" checked=""/>
7.4 <a href="docs/interrupts/exercise.html">Exercise</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>Lesson 8: Timers</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
8.1 <a href="docs/timers/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox" checked=""/>
8.2 <a href="docs/timers/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox" checked=""/>
8.3 <a href="docs/timers/kconfig.html">Kconfig</a></li>
<li><input disabled="" type="checkbox" checked=""/>
8.4 <a href="docs/timers/exercise.html">Exercise</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>Lesson 9: Mutexes</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
9.1 <a href="docs/mutexes/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox" checked=""/>
9.2 <a href="docs/mutexes/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox" checked=""/>
9.3 <a href="docs/mutexes/kconfig.html">Kconfig</a></li>
<li><input disabled="" type="checkbox"/>
9.4 <a href="docs/mutexes/exercise.html">Exercise</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>Lesson 10: Semaphores</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
10.1 <a href="docs/semaphores/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox" checked=""/>
10.2 <a href="docs/semaphores/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox" checked=""/>
10.3 <a href="docs/semaphores/kconfig.html">Kconfig</a></li>
<li><input disabled="" type="checkbox"/>
10.4 <a href="docs/semaphores/exercise.html">Exercise</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>Lesson 11: Logging</strong></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
11.1 <a href="docs/logging/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox" checked=""/>
11.2 <a href="docs/logging/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox" checked=""/>
11.3 <a href="docs/logging/kconfig.html">Kconfig</a></li>
<li><input disabled="" type="checkbox"/>
11.4 <a href="docs/logging/exercise.html">Exercise</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>Lesson 12: Build System</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
12.1 <a href="docs/build-system/introduction.html">Introduction</a></li>
<li><input disabled="" type="checkbox"/>
12.2 <a href="docs/build-system/commands.html">Commands</a></li>
<li><input disabled="" type="checkbox"/>
12.3 <a href="docs/build-system/exercise.html">Exercise</a></li>
<li><input disabled="" type="checkbox"/>
12.4 <a href="docs/build-system/next.html">Next?</a></li>
</ul>
</li>
</ul>
<h2 id="useful-links"><a class="header" href="#useful-links">Useful Links</a></h2>
<p><strong>General</strong></p>
<ul>
<li><a href="https://docs.zephyrproject.org/latest/">Zephyr Official Documentation</a></li>
<li><a href="https://www.youtube.com/watch?v=jR5E5Kz9A-k">Introduction to the Zephyr RTOS (video)</a></li>
<li><a href="https://github.com/fkromer/awesome-zephyr">awesome-zephyr</a></li>
</ul>
<p><strong>Youtube channels</strong></p>
<ul>
<li><a href="https://www.youtube.com/c/LinuxfoundationOrg/search?query=zephyr">The Linux Foundation</a></li>
<li><a href="https://www.youtube.com/c/ZephyrProject/videos">Zephyr Project</a></li>
</ul>
<p><strong>Projects using Zephyr</strong></p>
<ul>
<li><a href="https://github.com/golioth/zephyr-sdk">Golioth: IoT cloud platform</a></li>
<li><a href="https://github.com/scttnlsn/bms">Battery management system</a></li>
<li><a href="https://github.com/LairdCP/MG100_firmware">MG100: IoT sensor module</a></li>
<li><a href="https://github.com/Anylsite/anyl-wallet">Anyl: Embedded crypto wallet (for IoT)</a></li>
<li><a href="https://github.com/patrickmoffitt/zephyr_ble_sensor">BLE sensor</a></li>
<li><a href="https://github.com/endian-albin/pinetime-hypnos">PineTime smartwatch</a></li>
<li><a href="https://github.com/RT-LOC/zephyr-dwm1001">UWB position tracking</a></li>
<li><a href="https://github.com/zmkfirmware/zmk">zmk: mechanical keyboard firmware</a></li>
<li><a href="https://github.com/ExploratoryEngineering/air-quality-sensor-node">air quality sensor</a></li>
</ul>
<p><strong>Zephyr libraries</strong></p>
<ul>
<li><a href="https://github.com/zscilib/zscilib">Zephyr Scientific Library</a></li>
<li><a href="https://github.com/micro-ROS/micro_ros_zephyr_module">micro-ROS Zephyr module</a></li>
<li><a href="https://github.com/thesofproject/sof">sof: sound/DSP firmware</a></li>
</ul>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<p>Follow me on <a href="https://twitter.com/maksimdrachov">twitter</a>: stay up to date on my latest blogs/projects</p>
<h2 id="to-do"><a class="header" href="#to-do">To Do</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
gpio:commands.md -&gt; add descriptions to tables</li>
<li><input disabled="" type="checkbox"/>
exercices: threads : add define equivalents to each type</li>
<li><input disabled="" type="checkbox"/>
zephyr-setup: test proposed install and setup on 'tutorial'</li>
<li><input disabled="" type="checkbox"/>
introduction-&gt;rtos-basics: add explanatory images</li>
<li><input disabled="" type="checkbox"/>
threads-&gt;exercises: check build thread-start</li>
<li><input disabled="" type="checkbox"/>
debugging: core dump exercise</li>
</ul>
<p>towards the end:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Add next page and prev page links</li>
<li><input disabled="" type="checkbox"/>
exercises: rename project names</li>
<li>for each section introduction add relevant links at the end?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="zephyr-tutorial-introduction"><a class="header" href="#zephyr-tutorial-introduction">Zephyr Tutorial Introduction</a></h2>
<p><em>Why have I started writing this tutorial?</em></p>
<p>When I started learning Zephyr (~June 2021) I noticed it was difficult to find a clear and comprehensive guide for n00bs like myself. As I was learning I made a Gihub repository with personal notes and useful links. Eventually I decided to write a comprehensive tutorial - to give back to the open source community and to help others that might want to learn Zephyr. </p>
<p><em>Why on Github?</em></p>
<p>As Zephyr is a relatively new project and still very much evolving, I thought it made sense to write this tutorial in an open source manner. Therefore as things change, and the project evolves, it will remain possible to keep the information up-to-date. If you come across any code that is not working, information that is invalid (or out-of-date),... don't hesitate to raise an issue or submit a PR. I hope that with the help of the Zephyr community this can become an entry-point for all beginners.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="contributing-to-the-zephyr-rtos-tutorial"><a class="header" href="#contributing-to-the-zephyr-rtos-tutorial">Contributing to the Zephyr RTOS Tutorial</a></h2>
<p>The general workflow is the following:</p>
<ol>
<li>Find an <a href="https://github.com/maksimdrachov/zephyr-rtos-tutorial/issues">issue</a> you want to start working on or create a new one.</li>
<li>In comments claim that you want to take over the issue. The first person who does this will be assigned to the issue.</li>
<li><a href="https://help.github.com/articles/fork-a-repo/">Fork the repository</a>.</li>
<li>Make all necessary changes.</li>
<li><a href="https://help.github.com/articles/about-pull-requests/">Send a pull request</a>. </li>
<li>After a review, your changes will be merged.</li>
</ol>
<p>The following types of contributions are particularly useful for the project.</p>
<ol>
<li>Validating the source code and text of the lessons, fixing bugs and errors.</li>
<li>Help in making lessons content more accurate and easier to understand.</li>
<li>Working on the source code and content for new lessons.</li>
<li>Sharing source code of completed exercises.</li>
<li>Suggesting new exercises.</li>
<li>Providing feedback, requesting new features and content.</li>
<li>Anything else that can help the project.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="1-nucleo-f756zg"><a class="header" href="#1-nucleo-f756zg">1. <a href="https://www.st.com/en/evaluation-tools/nucleo-f756zg.html">NUCLEO-F756ZG</a></a></h3>
<p>This is the board that we'll be using for the tutorial, since Zephyr is platform-agnostic you can also use whatever you have laying around, but the commands might look slitghtly different for you.</p>
<p><a href="https://docs.zephyrproject.org/latest/boards/index.html#boards">Zephyr supported boards</a></p>
<h3 id="2-usb-to-micro-usb-cable"><a class="header" href="#2-usb-to-micro-usb-cable">2. <a href="https://www.google.com/search?q=micro+usb">USB to Micro-USB Cable</a></a></h3>
<p>This allows you to connect you Nucleo board through the debugger to your computer.</p>
<h3 id="3-ethernet-cable"><a class="header" href="#3-ethernet-cable">3. <a href="https://www.google.com/search?q=ethernet">Ethernet Cable</a></a></h3>
<p>If you want to learn about networking you'll need an ethernet cable and an ethernet port on your computer (or have access to the router).</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="docs/zephyr-setup/install/docs/zephyr-setup/install/mac-os.html">Installation MacOS</a></li>
<li><a href="docs/zephyr-setup/install/docs/zephyr-setup/install/windows.html">Installation Windows</a></li>
<li><a href="docs/zephyr-setup/install/docs/zephyr-setup/install/linux.html">Installation Linux</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install"><a class="header" href="#install">Install</a></h1>
<p><strong>1) Install dependencies</strong></p>
<ul>
<li>Install Homebrew</li>
</ul>
<pre><code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre>
<ul>
<li>Use brew to install the required dependencies</li>
</ul>
<pre><code>brew install cmake ninja gperf python3 ccache qemu dtc textmate    
</code></pre>
<p><strong>2) Clone Zephyr into new folder <code>zephyrproject</code></strong></p>
<pre><code>cd ~
mkdir zephyrproject
cd zephyrproject
git clone https://github.com/zephyrproject-rtos/zephyr
</code></pre>
<p><strong>3) Install <code>west</code></strong></p>
<ul>
<li>Install west</li>
</ul>
<pre><code>pip3 install -U west
</code></pre>
<ul>
<li>Get the Zephyr source code</li>
</ul>
<pre><code>west init ~/zephyrproject
cd ~/zephyrproject
west update
</code></pre>
<ul>
<li>Export a Zephyr CMake package. This allows CMake to automatically load <a href="https://en.wikipedia.org/wiki/Boilerplate_code">boilerplate</a> code required for building Zephyr applications.</li>
</ul>
<pre><code>west zephyr-export
</code></pre>
<ul>
<li>Zephyr’s <code>scripts/requirements.txt</code> file declares additional Python dependencies. Install them with <code>pip3</code>.</li>
</ul>
<pre><code>pip3 install -r ~/zephyrproject/zephyr/scripts/requirements.txt
</code></pre>
<p><strong>4) Install GNU ARM Embedded toolchain</strong></p>
<ul>
<li>Dowload <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNU ARM Embedded build</a> and extract in <code>~/dev-tools</code></li>
<li>Set environment variables in <code>~/.zshenv</code></li>
</ul>
<pre><code>mate .zshenv
</code></pre>
<p>Add the following lines. Make sure to use the right toolchain version, yours might be slightly different!</p>
<pre><code>export ZEPHYR_TOOLCHAIN_VARIANT=GNUARMEMB
export GNUARMEMB_TOOLCHAIN_PATH=/Users/maksim/dev-tools/gcc-arm-none-eabi-10.3-2021.07
</code></pre>
<ul>
<li>Restart terminal and check if environment variables are set up correctly
<img src="docs/zephyr-setup/install//images/zephyr-setup/env-var-check.png" alt="env_var_check" /></li>
</ul>
<p><strong>5) Build the Blinky sample</strong></p>
<pre><code>cd ~/zephyrproject/zephyr/samples/basic/blinky
west build -b nucleo_f756zg
</code></pre>
<p>A succesful build looks like this:
<img src="docs/zephyr-setup/install//images/zephyr-setup/succes-build.png" alt="succes_build" /></p>
<p><strong>6) Flash the Sample</strong></p>
<pre><code>cd ~/zephyrproject/zephyr/samples/basic/blinky
west flash
</code></pre>
<p>A succesful flash looks like this:
<img src="docs/zephyr-setup/install//images/zephyr-setup/succes-flash.png" alt="succes_flash" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>TODO**</p>
<div style="break-before: page; page-break-before: always;"></div><p>TODO**</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>
<p><a href="docs/zephyr-setup/setup/docs/zephyr-setup/setup/mac-os.html">Workspace Setup MacOS</a></p>
</li>
<li>
<p><a href="docs/zephyr-setup/setup/docs/zephyr-setup/setup/windows.html">Workspace Setup Windows</a></p>
</li>
<li>
<p><a href="docs/zephyr-setup/setup/docs/zephyr-setup/setup/linux.html">Workspace Setup Linux</a></p>
</li>
<li>
<p><a href="docs/zephyr-setup/setup/docs/zephyr-setup/setup/mac-os.html">Workspace Setup MacOS</a></p>
</li>
<li>
<p><a href="docs/zephyr-setup/setup/docs/zephyr-setup/setup/windows.html">Workspace Setup Windows</a></p>
</li>
<li>
<p><a href="docs/zephyr-setup/setup/docs/zephyr-setup/setup/linux.html">Workspace Setup Linux</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p><strong>1) Install VSCode</strong></p>
<ul>
<li>
<p>Add the following extensions to VSCode:</p>
<ul>
<li>C/C++</li>
<li>Cortex-Debug</li>
<li>DeviceTree</li>
</ul>
</li>
<li>
<p>Optional: <a href="https://stackoverflow.com/questions/42307949/color-theme-for-vs-code-integrated-terminal">set terminal color to green</a></p>
</li>
<li>
<p>Clone tutorial folder into <code>~/zephyrproject</code></p>
</li>
</ul>
<pre><code>cd ~/zephyrproject
git clone https://github.com/maksimdrachov/zephyr-rtos-tutorial

</code></pre>
<p><strong>2) Install Coolterm</strong></p>
<ul>
<li>
<p><a href="https://freeware.the-meiers.org/">Dowload</a></p>
</li>
<li>
<p>Connect your Nucleo board to your computer</p>
</li>
<li>
<p>Set up serial connection with Nucleo</p>
<ul>
<li>Port: usbmodemxxxxx</li>
<li>Baudrate: 115200</li>
</ul>
</li>
</ul>
<p><img src="docs/zephyr-setup/setup//images/zephyr-setup/coolterm-1.png" alt="coolterm-1" /></p>
<p>Terminal -&gt; check &quot;Filter ASCII Escape Sequences&quot;</p>
<p><img src="docs/zephyr-setup/setup//images/zephyr-setup/coolterm-2.png" alt="coolterm-2" /></p>
<p><code>File -&gt; Save</code></p>
<p>Save this configuration under <code>~/dev-tools/coolterm</code>, since you'll need it often.  (suggested name: nucleo-f756zg)</p>
<p><strong>3) Build and Flash basic-sample</strong></p>
<ul>
<li>
<p>Open the folder zephyr-rtos-tutorial in VScode</p>
</li>
<li>
<p>Open Coolterm with the <code>nucleo-f756zg</code> configuration and connect</p>
</li>
<li>
<p><code>Terminal -&gt; New Terminal</code></p>
</li>
</ul>
<pre><code>cd exercises/basic-sample
west build -b nucleo_f756zg
west flash
</code></pre>
<p>Tip: if you've previously made a build for a different board, remove the old build first:</p>
<p><code>rm -rf build</code></p>
<ul>
<li>Verify the serial output:</li>
</ul>
<p><img src="docs/zephyr-setup/setup//images/zephyr-setup/coolterm-3.png" alt="coolterm-3" /></p>
<p>Your final setup should look something like this:</p>
<p><img src="docs/zephyr-setup/setup//images/zephyr-setup/final-setup.png" alt="final-setup" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="rtos-basics"><a class="header" href="#rtos-basics">RTOS basics</a></h2>
<p><em>Why do I need an RTOS?</em></p>
<p>An RTOS is rarely a requirement, however as you start to increase the functionality of your embedded applications, it becomes increasingly harder to do everything within one single main loop and some interrupt routines. Usually the next level of complexity is some kind of state machine, where the output of your electronic device changes depending on this (internal) state. This however only gets you so far. For example, what if you need to be able to operate multiple complex inputs and outputs simultanously? A good example could be an TCP/IP connection, over which you'll be receiving some kind of data which then has to be used to operate a robotic arm, control an electric motor, send out a signal... It quickly becomes clear that a new level of abstraction is required to not drown in the complexity that would be required to implement something like that. This is where an RTOS comes in.</p>
<p>An RTOS is a suite of firmware that helps you build more complex apps, than would otherwise be feasible. It gives you the tools, the way you use those tools is however completely up to you! First and foremost it means having <strong>threads</strong>, this means that you'll be able to execute multiple tasks in parallel, neatly dividing them into their own area in memory. Then each RTOS provides varying levels of support for different protocols such as TCP/IP, Bluetooth, LoRaWan,... This makes your life easier, since now you won't have to study these protocols as in-depth. You'll get a series of API calls which should increase speed of development.</p>
<p><em>What makes Zephyr different from other RTOS'es?</em></p>
<p>As I haven't had the time to study other RTOS'es as in-depth I might be biased here. However from my point of view, studying Zephyr has the following benefits:</p>
<ul>
<li>Zephyr is supported by the Linux Foundation</li>
<li>By learning Zephyr you'll automatically get a taste for the Linux kernel. Both show some overlap in the way they are implemented, for example: Kconfig and devicetrees are some of the concepts borrowed by Zephyr from Linux</li>
<li>Zephyr is flexible: you can trade off footprint versus extra functionality (through Kconfig). If you don't know how this works don't worry, I'll explain this later.</li>
<li>Zephyr supports a wide variety of different dev boards/SoCs. </li>
<li>A more extensive lists of reasons can be found <a href="https://docs.zephyrproject.org/latest/introduction/index.html">here</a></li>
</ul>
<p><em>How does an RTOS work and what are some key concepts?</em> </p>
<p>Ok, so now that I've hopefully convinced you of the <em>use</em> of an RTOS, let's start by taking a look at <em>how</em> this all works. The first and most fundamental part of an RTOS is the <strong>kernel</strong>. The kernel is responsible for scheduling CPU time for each particular task so that they <em>appear</em> to be happening simultanously. The particulars of how this scheduling algorithm (or also called: <strong>scheduler</strong>) works is not important for now. </p>
<p>Each <strong>thread</strong> (or task) will use registers and memory as it executes. The whole of these processor registers and stack (memory) compromise the <strong>context</strong> of that particular thread. Once the RTOS decides to switch the thread and run something else, it will need to first <em>store</em> context away and then <em>load</em> in the context for the thread it wants to run next. This process is called <strong>context switching</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="zephyr-structure"><a class="header" href="#zephyr-structure">Zephyr structure</a></h2>
<p><em>How to work with Zephyr?</em> </p>
<p>Before we start writing our first applications in Zephyr, it might be a good step to take a look at the folder structure that Zephyr provides us.</p>
<p><img src="docs/introduction//images/introduction/sample-folder.png" alt="sample-folder" /></p>
<p>Let's go one-by-one:</p>
<h3 id="build"><a class="header" href="#build">build</a></h3>
<p>This folder appears only once you have build your application and contains the files that get flashed onto the microcontroller. </p>
<p>The following files are sometimes interesting to take a look at:</p>
<ul>
<li><strong>build/zephyr/zephyr.dts</strong>: CMake uses a devicetree to tailor the build towards your specific architecture/board. This is the final version of that file. If you don't understand what a devicetree is, don't worry we'll cover this in more detail later.</li>
<li><strong>build/zephyr/.config</strong>: The final Kconfig used for your built. This can be useful to verify if a setting has been set correctly.</li>
</ul>
<h3 id="cmakeliststxt"><a class="header" href="#cmakeliststxt">CMakeLists.txt</a></h3>
<p>This file will be used by <a href="https://en.wikipedia.org/wiki/CMake">CMake</a> to set up your build, during this tutorial you won't need to change this one.</p>
<h3 id="prjconf"><a class="header" href="#prjconf">prj.conf</a></h3>
<p>This is you Kconfig file. Important! This file will contain any <em>additional</em> settings you'll set for your Zephyr configuration. For example if you need TCP/IP, Bluetooth or want to make changes to your scheduler,... We'll explore some of the options throughout this tutorial.</p>
<p><img src="docs/introduction//images/introduction/k-config.png" alt="k-config" /></p>
<p>Right now it's pretty empty, since for the basic-sample we don't need anything &quot;fancy&quot;, just the basic Zephyr kernel. We only set CONFIG_PRINTK=y , this will allow us to the printk function to output to the serial (which will be displayed on your computer screen).</p>
<p>If you're ever unsure about what a particular config setting does, you have 2 options:</p>
<ul>
<li>Use <a href="https://www.google.com/search?client=firefox-b-d&amp;q=zephyr+CONFIG_PRINTK">google</a>: usually Zephyr Documentation is one of the first links</li>
<li>Use the guiconfig: in your basic-sample folder execute <code>west build -t guiconfig</code>. This will show you a menu of all the possible configuration settings and a small description of what each one does. (Use <code>Jump to</code> to find your config)
<img src="docs/introduction//images/introduction/guiconfig.png" alt="guiconfig" />. </li>
</ul>
<h3 id="src"><a class="header" href="#src">src</a></h3>
<p>Where the magic happens! This folder should contain all of your custom application code. For now it should only contain <code>main.c</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="threads"><a class="header" href="#threads">Threads</a></h2>
<p><em>What are threads?</em> </p>
<p>A thread is an isolated instance that is responsible for the execution of some task. While a microcontroller usually only has 1 CPU, the RTOS is able to have multiple tasks execute (seemingly) simultanously by exchanging the thread that gets run on the CPU as dictated by the scheduler. </p>
<p>Some key concepts:</p>
<ul>
<li><strong>Stack area</strong>: a region of memory used for the thread's stack. The size can be adjusted as required by the thread's processing.</li>
</ul>
<p><img src="docs/threads//images/threads/thread-stack-size.png" alt="thread-stack-size" /></p>
<ul>
<li><strong>Thread control block</strong>: for internal bookkeeping of the thread's metadata. An instance of the type <code>k_thread</code>.</li>
</ul>
<p><img src="docs/threads//images/threads/thread-control-block.png" alt="thread-control-block" /></p>
<ul>
<li><strong>Entry point function</strong>: invoked when the thread is started. Up to 3 argument values can be passed to this function.</li>
</ul>
<p><img src="docs/threads//images/threads/thread-entry-point.png" alt="thread-entry-point" /></p>
<p><em>ARG_UNUSED is needed to indicate that the 3 arguments are not used in our thread function.</em></p>
<ul>
<li><strong>Scheduling policy</strong>: intstructs the kernel's scheduler how to allocate CPU time to the thread. (This will be covered in <code>Scheduling</code>)</li>
<li><strong>Execution mode</strong>: can be supervisor or user mode. By default, threads run in supervisor mode and allow access to privileged CPU instructions, the entire memory address space, and peripherals. User mode threads have a reduced set of privileges.</li>
</ul>
<p>The specifics of how to define a thread will be discussed in the next section</p>
<h2 id="thread-states"><a class="header" href="#thread-states">Thread states</a></h2>
<p><em>How does Zephyr choose which thread to run?</em></p>
<p>&quot;Thread is ready&quot; = eligible to be selected as the next running thread.</p>
<p>Following factors can make a thread unready:</p>
<ul>
<li>Thread has not been started</li>
<li>Waiting for a kernel object to complete an operation (for example, the thread is taking semaphore that is unavailable)</li>
<li>Waiting for a timeout to occur</li>
<li>Thread has been suspended</li>
<li>Thread has terminated or aborted</li>
</ul>
<p>The following diagram shows all the possible states a thread can find itself:</p>
<p><img src="docs/threads//images/threads/thread-states.png" alt="thread_states" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="thread-creation"><a class="header" href="#thread-creation">Thread creation</a></h2>
<p><em>How do I define threads in Zephyr?</em></p>
<p>A thread is spawned by defining its stack area and its thread control block, and then calling k_thread_create().</p>
<p>The stack area must be defined using K_THREAD_STACK_DEFINE or K_KERNEL_STACK_DEFINE to ensure it is properly set up in memory.</p>
<p>The thread spawning function returns its thread id, which can be used to reference the thread.</p>
<pre><code class="language-c">#define MY_STACK_SIZE 500
#define MY_PRIORITY 5

extern void my_entry_point(void *, void *, void *);

K_THREAD_STACK_DEFINE(my_stack_area, MY_STACK_SIZE);
struct k_thread my_thread_data;

k_tid_t my_tid = k_thread_create(&amp;my_thread_data, my_stack_area,
                                 K_THREAD_STACK_SIZEOF(my_stack_area),
                                 my_entry_point,
                                 NULL, NULL, NULL,
                                 MY_PRIORITY, 0, K_NO_WAIT);
</code></pre>
<p>In order to define a thread you'll need to initiate some parameters:</p>
<pre><code class="language-c">k_tid_t k_thread_create(struct k_thread *new_thread, k_thread_stack_t *stack, size_t stack_size, k_thread_entry_t entry, void *p1, void *p2, void *p3, int prio, uint32_t options, k_timeout_t delay)

</code></pre>
<p>Parameters:</p>
<ul>
<li><code>new_thread</code> – Pointer to uninitialized struct k_thread</li>
<li><code>stack</code> – Pointer to the stack space.</li>
<li><code>stack_size</code> – Stack size in bytes.</li>
<li><code>entry</code> – Thread entry function.</li>
<li><code>p1</code> – 1st entry point parameter.</li>
<li><code>p2</code> – 2nd entry point parameter.</li>
<li><code>p3</code> – 3rd entry point parameter.</li>
<li><code>prio</code> – Thread priority.</li>
<li><code>options</code> – Thread options.</li>
<li><code>delay</code> – Scheduling delay, or K_NO_WAIT (for no delay).</li>
</ul>
<p>Returns:</p>
<ul>
<li>ID of new thread.</li>
</ul>
<p>Alternatively, a thread can be declared at compile time by calling K_THREAD_DEFINE. Observe that the macro defines the stack area, control block, and thread id variables automatically.</p>
<p>The following code has the same effect as the code segment above.</p>
<pre><code class="language-c">#define MY_STACK_SIZE 500
#define MY_PRIORITY 5

extern void my_entry_point(void *, void *, void *);

K_THREAD_DEFINE(my_tid, MY_STACK_SIZE,
                my_entry_point, NULL, NULL, NULL,
                MY_PRIORITY, 0, 0);
</code></pre>
<h2 id="thread-commands"><a class="header" href="#thread-commands">Thread commands</a></h2>
<h3 id="k_thread_start"><a class="header" href="#k_thread_start">k_thread_start()</a></h3>
<p>A thread must be created before it can be used.</p>
<p><img src="docs/threads//svg-images/threads/thread-start.png" alt="k_thread_im" /></p>
<h3 id="k_thread_abort"><a class="header" href="#k_thread_abort">k_thread_abort()</a></h3>
<p>Abort a thread. Thread is taken off all kernel queues.</p>
<p><img src="docs/threads//svg-images/threads/thread-abort.png" alt="k_thread_im" /></p>
<h3 id="k_sleep"><a class="header" href="#k_sleep">k_sleep()</a></h3>
<p>A thread can prevent itself from executing for a specified amount of time. A sleeping thread becomes executable automatically once the time limit is reached.</p>
<p><img src="docs/threads//svg-images/threads/thread-sleep.png" alt="k_thread_im" /></p>
<h3 id="k_thread_suspend"><a class="header" href="#k_thread_suspend">k_thread_suspend()</a></h3>
<p>Prevent a thread from executing for an indefinite period of time. Once suspended, use k_thread_resume() to re-start.</p>
<p><img src="docs/threads//svg-images/threads/thread-suspend.png" alt="k_thread_im" /></p>
<h3 id="k_thread_join"><a class="header" href="#k_thread_join">k_thread_join()</a></h3>
<p>Sleep until a thread exits. </p>
<p>For example:</p>
<ul>
<li>thread_b is responsible for setting up a hardware interface</li>
<li>thread_a is responsible for processing data from this interface</li>
<li>As long as thread_b has not exited, thread_a can't start, so we'll use k_thread_join(thread_b, timeout) in this case.</li>
</ul>
<p><img src="docs/threads//svg-images/threads/thread-join.png" alt="k_thread_im" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kconfig"><a class="header" href="#kconfig">Kconfig</a></h2>
<p>Threads are always included in the system configuration, therefore no <em>additional</em> configs need to be set. </p>
<p>However <em>optionally</em> the following configuration options can be set:</p>
<table><thead><tr><th>Kconfig</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_MAIN_THREAD_PRIORITY.html">CONFIG_MAIN_THREAD_PRIORITY</a></td><td>Priority of initialization/main thread</td></tr>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_MAIN_STACK_SIZE.html">CONFIG_MAIN_STACK_SIZE</a></td><td>Size of stack for initialization and main thread</td></tr>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_IDLE_STACK_SIZE.html">CONFIG_IDLE_STACK_SIZE</a></td><td>Size of stack for idle thread</td></tr>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_THREAD_CUSTOM_DATA.html">CONFIG_THREAD_CUSTOM_DATA</a></td><td>This option allows each thread to store 32 bits of custom data, which can be accessed using the k_thread_custom_data_xxx() APIs.</td></tr>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_NUM_COOP_PRIORITIES.html">CONFIG_NUM_COOP_PRIORITIES</a></td><td>Number of cooperative priorities configured in the system</td></tr>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_NUM_PREEMPT_PRIORITIES.html">CONFIG_NUM_PREEMPT_PRIORITIES</a></td><td>Number of preemptible priorities available in the system</td></tr>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_TIMESLICING.html">CONFIG_TIMESLICING</a></td><td>This option enables time slicing between preemptible threads of equal priority.</td></tr>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_TIMESLICE_SIZE.html">CONFIG_TIMESLICE_SIZE</a></td><td>This option specifies the maximum amount of time a thread can execute before other threads of equal priority are given an opportunity to run. A time slice size of zero means &quot;no limit&quot; (i.e. an infinitely large time slice).</td></tr>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_TIMESLICE_PRIORITY.html">CONFIG_TIMESLICE_PRIORITY</a></td><td>This option specifies the thread priority level at which time slicing takes effect; threads having a higher priority than this ceiling are not subject to time slicing.</td></tr>
<tr><td><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_USERSPACE.html">CONFIG_USERSPACE</a></td><td>When enabled, threads may be created or dropped down to user mode, which has significantly restricted permissions and must interact with the kernel via system calls.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p>For solving the exercises I recommend you create your own folder inside <code>zephyr-rtos-tutorial</code> which contains the following filetree.</p>
<pre><code>.
└── my-exercises
    ├── threads
    │   ├── thread-start
    │   ├── thread-start-define
    │   ├── thread-abort
    │   ├── thread-sleep
    │   ├── thread-suspend
    │   └── thread-join
    ├── gpio
    ├── scheduling
    ├── debugging
    ├── interrupts
    ├── timers
    ├── mutexes
    ├── semaphores
    ├── logging
    └── networking
</code></pre>
<p><strong>thread creation: main</strong></p>
<ul>
<li>Use <code>k_thread_create()</code> to create a thread</li>
<li>Implement the following</li>
</ul>
<p><img src="docs/threads//svg-images/threads/thread-start.png" alt="thread-start" /></p>
<ul>
<li>Output the following serial using <code>printk()</code></li>
</ul>
<p><img src="docs/threads//images/threads/thread-start.png" alt="thread-start" /></p>
<p>solution: <code>exercises/threads/thread-start</code></p>
<p><strong>thread creation: define</strong></p>
<ul>
<li>Same as previous, but this time using <code>K_THREAD_DEFINE</code> to create thread</li>
</ul>
<p>solution: <code>exercises/threads/thread-start-define</code></p>
<p><strong>thread abort</strong></p>
<ul>
<li>Implement the following</li>
</ul>
<p><img src="docs/threads//svg-images/threads/thread-abort.png" alt="thread-abort" /></p>
<ul>
<li>Output the following serial using <code>printk()</code></li>
</ul>
<p><img src="docs/threads//images/threads/thread-abort.png" alt="thread-abort" /></p>
<p>solution: <code>exercises/threads/thread-abort</code></p>
<p><strong>thread sleep</strong></p>
<ul>
<li>Implement the following</li>
</ul>
<p><img src="docs/threads//svg-images/threads/thread-sleep.png" alt="thread-sleep" /></p>
<ul>
<li>Output the following serial using <code>printk()</code></li>
</ul>
<p><img src="docs/threads//images/threads/thread-sleep.png" alt="thread-sleep" /></p>
<p>solution: <code>exercises/threads/thread-sleep</code></p>
<p><strong>thread suspend</strong></p>
<ul>
<li>Implement the following</li>
</ul>
<p><img src="docs/threads//svg-images/threads/thread-suspend.png" alt="thread-sleep" /></p>
<ul>
<li>Output the following serial using <code>printk()</code></li>
</ul>
<p><img src="docs/threads//images/threads/thread-suspend.png" alt="thread-sleep" /></p>
<p>solution: <code>exercises/threads/thread-suspend</code></p>
<p><strong>thread join</strong></p>
<ul>
<li>Implement the following</li>
</ul>
<p><img src="docs/threads//svg-images/threads/thread-join.png" alt="thread-join" /></p>
<ul>
<li>Output the following serial using <code>printk()</code></li>
</ul>
<p><img src="docs/threads//images/threads/thread-join.png" alt="thread-join" /></p>
<p>solution: <code>exercises/threads/thread-join</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In this lesson we'll be covering the way GPIO works in Zephyr. Just the basics:</p>
<ul>
<li>set up an input pin</li>
<li>set up an output pin</li>
<li>set up an interrupt pin</li>
</ul>
<h2 id="gpio-setup"><a class="header" href="#gpio-setup">GPIO setup</a></h2>
<p>When setting up any GPIO the following basic steps have to be followed:</p>
<ol>
<li>First you need to look up the devicetree binding for the corresponding GPIO (if you don't know what a devicetree is: see section below).</li>
</ol>
<p>The devicetree for your particular build can be found at <code>build/zephyr/zephyr.dts</code> or for each board in <code>zephyrproject/zephyr/boards</code></p>
<p>For example, the red arrow indicates the device binding to toggle the green led.
<img src="docs/gpio//images/gpio/devicetree-binding.png" alt="devicetree-binding" /></p>
<ol start="2">
<li>To use the device binding in our main.c file; we need to use the following defines:</li>
</ol>
<ul>
<li>Devicetree node identifier</li>
</ul>
<pre><code>#define LED0_NODE DT_ALIAS(led0) 
</code></pre>
<p>Notice how we used <code>led0</code> instead of <code>green_led</code> here? This is possible due to the following aliases being defined: </p>
<pre><code>aliases {
	led0 = &amp;green_led;
	led1 = &amp;blue_led;
	led2 = &amp;red_led;
	sw0 = &amp;user_button;
};
</code></pre>
<p>Now we use LED0_NODE to obtain all other (optional) defines:</p>
<ul>
<li>Label</li>
</ul>
<pre><code>#define LED0    DT_GPIO_LABEL(LED0_NODE, gpios)
</code></pre>
<ul>
<li>Pin</li>
</ul>
<pre><code>#define PIN	    DT_GPIO_PIN(LED0_NODE, gpios)
</code></pre>
<ul>
<li>(Default) flags</li>
</ul>
<pre><code>#define FLAGS	DT_GPIO_FLAGS(LED0_NODE, gpios)
</code></pre>
<p>Optionally, instead of using 'defines', you can use <code>gpio_dt_spec</code>: </p>
<pre><code>static struct gpio_dt_spec led = GPIO_DT_SPEC_GET_OR(DT_ALIAS(led0), gpios, {0});

static const struct gpio_dt_spec button = GPIO_DT_SPEC_GET_OR(SW0_NODE, gpios, {0});
</code></pre>
<ol start="3">
<li>Configure GPIO</li>
</ol>
<ul>
<li>input/output configuration</li>
</ul>
<pre><code class="language-c">const struct device *dev;

dev = device_get_binding(LED0);

ret = gpio_pin_configure(dev, PIN, GPIO_INPUT | FLAGS); // For input pin

ret = gpio_pin_configure(dev, PIN, GPIO_OUTPUT | FLAGS); // For output pin
</code></pre>
<ul>
<li>interrupt configuration</li>
</ul>
<pre><code>ret = gpio_pin_interrupt_configure(dev, PIN, GPIO_INT_EDGE_RISING | FLAGS); // For rising edge interrupt
</code></pre>
<p>Using <code>gpio_dt_spec</code></p>
<ul>
<li>input/output configuration</li>
</ul>
<pre><code>ret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT);
ret = gpio_pin_configure_dt(&amp;button, GPIO_INPUT);
</code></pre>
<ul>
<li>interrupt configuration</li>
</ul>
<pre><code>gpio_pin_interrupt_configure_dt(&amp;button, GPIO_INT_EDGE_RISING);
</code></pre>
<ol start="4">
<li>Use GPIO through dedicated functions (set, read, toggle,...)</li>
</ol>
<ul>
<li>set </li>
</ul>
<pre><code class="language-c">gpio_pin_set(dev, PIN, led_state);
</code></pre>
<ul>
<li>read</li>
</ul>
<pre><code class="language-c">button_state = gpio_pin_get(dev, PIN);
</code></pre>
<ul>
<li>toggle</li>
</ul>
<pre><code class="language-c">gpio_pin_toggle(dev, PIN);
</code></pre>
<p>Using <code>gpio_dt_spec</code></p>
<ul>
<li>set</li>
</ul>
<pre><code>int val = gpio_pin_set_dt(&amp;led, val);
</code></pre>
<ul>
<li>read</li>
</ul>
<pre><code>int val = gpio_pin_get_dt(&amp;button);
</code></pre>
<ul>
<li>toggle</li>
</ul>
<pre><code>gpio_pin_toggle_dt(&amp;led);
</code></pre>
<h2 id="devicetree"><a class="header" href="#devicetree">Devicetree</a></h2>
<blockquote>
<p>A device tree is a data structure describing the hardware components of a particular computer so that the operating system's kernel can use and manage those components, including the CPU or CPUs, the memory, the buses and the peripherals. (wikipedia)</p>
</blockquote>
<p>In short: the devicetree will help Zephyr locate all the components of your particular SoC/Board and in this way it will be able to work regardless of the underlying hardware. That also means if we want to access anything on the board from within Zephyr, we'll need to know the binding of that particular component in our devicetree. For example, if we want to blink an LED on the board, we'll first have to determine how that LED is called in the devicetree. If you want to learn more about devicetree, I'd recommend watching <a href="https://www.youtube.com/watch?v=m_NyYEBxfn8">this</a> video, which explains it pretty well. (devicetree is a concept borrowed from Linux)</p>
<p>The devicetree for the dev board (nucleo-f756zg) can be be found at <code>zephyrproject/zephyr/boards/arm/nucleo_f756zg</code> and for the microcontroller itself (stm32f756) at <code>zephyrproject/zephyr/dts/arm/st/f7/stm32f756Xg.dtsi</code>. If you study the devicetree files, you'll notice that the final devicetree is a combination of multiple files; the way this works is that each successive devicetree file gets laid over the previous one thereby forming a final devicetree (to be found in <code>build/zephyr/zephyr.dts</code>) this one should match your particular dev board and microcontroller. </p>
<div style="break-before: page; page-break-before: always;"></div><p>Useful API pages:</p>
<ul>
<li><a href="https://docs.zephyrproject.org/latest/reference/peripherals/gpio.html#api-reference">GPIO API</a></li>
<li><a href="https://docs.zephyrproject.org/latest/guides/dts/index.html">Devicetree</a></li>
<li><a href="https://docs.zephyrproject.org/latest/reference/drivers/index.html">Device Driver Model</a></li>
</ul>
<h2 id="functions-table"><a class="header" href="#functions-table">Functions table</a></h2>
<table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td>gpio_pin_configure</td><td>Configure a single pin</td></tr>
<tr><td>gpio_pin_interrupt_configure</td><td>Configure pin interrupt</td></tr>
<tr><td>gpio_pin_get</td><td>Get logical level of an input pin - taking into account the GPIO_ACTIVE_LOW flag. If pin is configured as Active High, a low physical level will be interpreted as logical value 0. If pin is configured as Active Low, a low physical level will be interpreted as logical value 1.</td></tr>
<tr><td>gpio_pin_set</td><td>Set logical level of an output pin taking into account GPIO_ACTIVE_LOW flag. Value 0 sets the pin in logical 0 / inactive state. Any value other than 0 sets the pin in logical 1 / active state. If pin is configured as Active High, the default, setting it in inactive state will force the pin to a low physical level. If pin is configured as Active Low, setting it in inactive state will force the pin to a high physical level.</td></tr>
<tr><td>gpio_pin_toggle</td><td>Toggle pin level</td></tr>
</tbody></table>
<p>Callback functions: (not covered in exercises)
| Function | Description |
| --- | --- |
| gpio_init_callback | Helper to initialize a struct <code>gpio_callback</code> properly |
| gpio_add_callback | Add an application callback |
| gpio_remove_callback | Remove an application callback |</p>
<p>Device Driver Model
| Function | Description |
| --- | --- |
| device_get_binding | Retrieve the device structure for a driver by name. Device objects are created via the DEVICE_DEFINE() macro and placed in memory by the linker. If a driver needs to bind to another driver it can use this function to retrieve the device structure of the lower level driver by the name the driver exposes to the system.|</p>
<h2 id="flags-table"><a class="header" href="#flags-table">Flags table</a></h2>
<p>Input/Output configuration options:
| Flags | Description
| --- | --- | 
| GPIO_INPUT | Enables pin as input |
| GPIO_OUTPUT | Enables pin as output, no change to the output state |
| GPIO_DISCONNECTED | Disables pin for both input and output.  |
| GPIO_OUTPUT_LOW | Configures GPIO pin as output and initializes it to a low state.  |
| GPIO_OUTPUT_HIGH | Configures GPIO pin as output and initializes it to a high state. |
| GPIO_OUTPUT_INACTIVE | Configures GPIO pin as output and initializes it to a logic 0. |
| GPIO_OUTPUT_ACTIVE | Configures GPIO pin as output and initializes it to a logic 1.  |</p>
<p>GPIO interrupt configuration flags
| Flags | Description |
| --- | --- |
| GPIO_INT_DISABLE | Disables GPIO pin interrupt. |
| GPIO_INT_EDGE_RISING | Configures GPIO interrupt to be triggered on pin rising edge and enables it. |
| GPIO_INT_EDGE_FALLING | Configures GPIO interrupt to be triggered on pin falling edge and enables it. |
| GPIO_INT_EDGE_BOTH | Configures GPIO interrupt to be triggered on pin rising or falling edge and enables it. |
| GPIO_INT_LEVEL_LOW | Configures GPIO interrupt to be triggered on pin physical level low and enables it. |
| GPIO_INT_LEVEL_HIGH | Configures GPIO interrupt to be triggered on pin physical level high and enables it. |
| GPIO_INT_EDGE_TO_INACTIVE | Configures GPIO interrupt to be triggered on pin state change to logical level 0 and enables it. |
| GPIO_INT_EDGE_TO_ACTIVE | Configures GPIO interrupt to be triggered on pin state change to logical level 1 and enables it. |
| GPIO_INT_LEVEL_INACTIVE | Configures GPIO interrupt to be triggered on pin logical level 0 and enables it. |
| GPIO_INT_LEVEL_ACTIVE | Configures GPIO interrupt to be triggered on pin logical level 1 and enables it. |</p>
<p>GPIO pin active level flags
| Flags | Description |
| --- | --- |
| GPIO_ACTIVE_LOW | GPIO pin is active (has logical value ‘1’) in low state.  |
| GPIO_ACTIVE_HIGH | GPIO pin is active (has logical value ‘1’) in high state.  |</p>
<p>Defines
| Flags | Description |
| --- | --- |
| GPIO_INT_DEBOUNCE | Enable GPIO pin debounce |
| GPIO_DT_SPEC_GET_BY_IDX | This returns a static initializer for a <code>gpio_dt_spec</code> structure given a devicetree node identifier, a property specifying a GPIO and an index. |</p>
<table><thead><tr><th>Flags</th><th>Description</th></tr></thead><tbody>
<tr><td>DT_ALIAS</td><td>Get a node identifier from /aliases.</td></tr>
<tr><td>DT_GPIO_LABEL</td><td>Get a label property from a gpio phandle-array property (at index 0)</td></tr>
<tr><td>DT_GPIO_PIN</td><td>Get a GPIO specifier’s pin cell (at index 0)</td></tr>
<tr><td>DT_GPIO_FLAGS</td><td>Get a GPIO specifier’s flags cell (at index 0)</td></tr>
</tbody></table>
<p>Additional flag categories can be found <a href="https://docs.zephyrproject.org/latest/reference/peripherals/gpio.html#api-reference">here</a>:</p>
<ul>
<li>GPIO drive strength flags</li>
<li>GPIO pin drive flags</li>
<li>GPIO pin bias flags</li>
<li>GPIO pin voltage flags</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="required-kconfig"><a class="header" href="#required-kconfig">Required Kconfig</a></h2>
<pre><code>CONFIG_GPIO=y
</code></pre>
<p>Includes GPIO drivers in system configuration</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="blinky"><a class="header" href="#blinky">Blinky</a></h2>
<p>GPIO-output</p>
<p>Make a 1 Hz blinky program.</p>
<p>solution: <code>exercises/gpio/blinky</code></p>
<h2 id="button"><a class="header" href="#button">Button</a></h2>
<p>GPIO-input</p>
<p>Use button to turn LED on or off.</p>
<p>solution: <code>exercises/gpio/button</code></p>
<h2 id="2-leds"><a class="header" href="#2-leds">2 LEDs</a></h2>
<p>Threads + GPIO</p>
<p>Blinky for 2 LED at different frequencies, using different threads.</p>
<p>solution: <code>exercises/gpio/two-leds</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p><em>What is &quot;scheduling&quot;?</em></p>
<p>The scheduler determines which thread is allowed to execute at any point in time; this thread is known as the current thread.</p>
<p>There are various points in time when the scheduler is given an opportunity to change the identity of the current thread. These points are called reschedule points. Some potential reschedule points are:</p>
<ul>
<li>transition of a thread from running state to a suspended or waiting state, for example by k_sem_take() or k_sleep().</li>
<li>transition of a thread to the ready state, for example by k_sem_give() or k_thread_start()</li>
<li>return to thread context after processing an interrupt</li>
<li>when a running thread invokes k_yield()</li>
</ul>
<p>A thread sleeps when it volutarily initiates an operation that transitions itself to a suspended or waiting state.</p>
<p>Whenever the scheduler changes the identity of the current thread, or when execution of the current thread is replaced by an ISR, the kernel first saves the current thread's CPU register values. These register values get restored when the thread later resumes execution.</p>
<h2 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h2>
<p><em>How does the scheduler work?</em></p>
<p>The kernel's scheduler selects the highest priority ready thread to be the current thread. When multiple ready threads of the same priority exist, the scheduler chooses the one that has been waiting the longest. </p>
<p>Note: execution of ISRs takes precedence over thread execution. Unless interrupts have been masked, the current thread can be replaced by an ISR at any time.</p>
<p>The kernel can be built with one of several choices for the ready queue implementation. The choice is a trade-off between:</p>
<ul>
<li>code size</li>
<li>constant factor runtime overhead</li>
<li>performance scaling when many threads are involved</li>
</ul>
<p>Your Kconfig-file (<code>prj.conf</code>) should contain one of the following (or it will default to simple linked-list).</p>
<p>The queue types: </p>
<ul>
<li>Simple linked-list ready queue (<code>CONFIG_SCHED_DUMB</code>)
<ul>
<li>simple unordered list</li>
<li>very fast constant time performance for single threads</li>
<li>very low code size</li>
<li>useful for systems with:
<ul>
<li>constrained code size</li>
<li>small number of threads (&lt;=3) at any given time</li>
</ul>
</li>
</ul>
</li>
<li>Red/black tree ready queue (<code>CONFIG_SCHED_SCALABLE</code>)
<ul>
<li>red/black tree (<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">wiki</a>)</li>
<li>slower constant time insertion and removal overhead</li>
<li>requires extra 2Kb code</li>
<li>scales cleanly and quickly into many thousands of threads</li>
<li>Useful for systems with:
<ul>
<li>many concurrent runnable threads (&gt;20 or so)</li>
</ul>
</li>
</ul>
</li>
<li>Traditional multi-queue ready queue (<code>CONFIG_SCHED_MULTIQ</code>)
<ul>
<li>classic array of lists, one per priority (max 32 priorities)</li>
<li>tine code size overhead vs. the &quot;dumb&quot; scheduler</li>
<li>runs in 0(1) time with very low constant factor</li>
<li>requires fairly large RAM budget to store list heads</li>
<li>incompatible with <a href="https://www.geeksforgeeks.org/deadline-scheduler-in-operating-system/">deadline scheduling</a> and <a href="https://cs.uwaterloo.ca/%7Ebrecht/servers/apic/SMP-affinity.txt">SMP affinity</a></li>
<li>systems with small # of threads (but usually DUMB is good enough)</li>
</ul>
</li>
<li>Scalable wait_q implementation (<code>CONFIG_WAITQ_SCALABLE</code>)</li>
<li>Simple linked-list wait_q (<code>CONFIG_WAITQ_DUMB</code>)</li>
</ul>
<h2 id="thread-priorities"><a class="header" href="#thread-priorities">Thread priorities</a></h2>
<p><em>How do thread priorities work?</em></p>
<p>A thread's priority is an integer value, and can be either negative or non-negative. Numerically lower priorities take precedence over higher values (-5&gt;6).</p>
<p>The scheduler distinguishes between two classes of threads, based on each thread's priority. </p>
<ul>
<li>A cooperative thread has a negative priority value. Once it becomes the current thread, a cooperative thread remains the current thread until it performs an action that makes it unready.</li>
<li>A preemptible thread has a non-negative priority value. Once it becomes the current thread, a preemptible thread may be supplanted at any time if a cooperative thread, or a preemptible thread of higher or equal priority, becomes ready.</li>
</ul>
<p>A thread's initial priority value can be altered up or down after the thread has been started. Thus it is possible for a preemptible thread to become a cooperative thread, and vice versa.</p>
<p>The kernel supports a virtually unlimited number of thread priority levels. The configuration options CONFIG_NUM_COOP_PRIORITIES and CONFIG_NUM_PREEMPT_PRIORITIES specify the number of priority levels for each class of thread, resulting in the following usable priority ranges:</p>
<ul>
<li>cooperative threads: (-CONFIG_NUM_COOP_PRIORITIES) to -1</li>
<li>preemptive threads: 0 to (CONFIG_NUM_PREEMPT_PRIOTIES-1) </li>
</ul>
<h2 id="cooperative-time-slicing"><a class="header" href="#cooperative-time-slicing">Cooperative Time Slicing</a></h2>
<p><em>What is cooperative time slicing?</em>
Once a cooperative thread becomes the current thread, it remains the current thread until it performs an action that makes it unready. Consequently, if a cooperative thread performs lengthy computations, it may cause an unacceptable delay in the scheduling of other threads, including those of higher priority.</p>
<p><img src="docs/scheduling//images/scheduling/cooperative.png" alt="cooperative" /></p>
<p>To overcome such problems, a cooperative thread can voluntarily relinquish the CPU from time to time to permit other threads to execute. A thread can relinquish the CPU in two ways:</p>
<ul>
<li>Calling k_yield() puts the thread at the back of the scheduler's prioritized list of ready threads, and then invokes the scheduler. All ready threads whose priority is higher or equal to that of the yielding thread are then allowed to execute before the yielding thread is rescheduled. If no such threads exist, the scheduler immediately reschedules the yielding thread without context switching. </li>
<li>Calling k_sleep() makes the thread unready for a specified time period. Ready threads of <em>all</em> priorities are then allowed to execute; however, there is no guarantee that threads whose priority is lower than that of the sleeping thread will actually be scheduled before the sleeping thread becomes ready once again.</li>
</ul>
<h2 id="preemptive-time-slicing"><a class="header" href="#preemptive-time-slicing">Preemptive Time Slicing</a></h2>
<p><em>What is preemptive time slicing?</em></p>
<p>Once a preemptive thread becomes the current thread, it remains the current thread until a higher priority thread becomes ready, or until the thread performs an action that makes it unready. Consequently, if a preemptive thread performs lengthy computations, it may cause an unacceptable delay in the scheduling of other threads, including those of equal priority. </p>
<p><img src="docs/scheduling//images/scheduling/preemptive.png" alt="preemptive" /></p>
<p>To overcome such problems, a preemptive thread can perform cooperative time slicing (as described above), or the scheduler's time slicing capability can be used to allow other threads of the same priority to execute.</p>
<p><img src="docs/scheduling//images/scheduling/timeslicing.png" alt="timeslicing" /></p>
<p>The scheduler divides time into a series of time slices, where slices are measured in system clock ticks. The time slice size is configurable, but this size can be changed while the application is running.</p>
<p>At the end of every time slice, the scheduler checks to see if the current thread is preemptible and, if so, implicitly invokes k_yield() on behalf of the thread. This gives other ready threads of the same priority the opportunity to execute before the current thread is scheduled again. If no threads of equal priority are ready, the current thread remains.</p>
<p>Threads with a priority higher than the specified limit are exempt from preemptive time slicing, and are never preempted by a thread of equal priority. This allows an application to use preemptive time slicing only when dealing with lower priority threads that are less time-sensitive.</p>
<p>Note: the kernel's time slicing algorithm does not ensure that a set of equal-priority threads receive an equitable amount of CPU time, since it does not measure the amount of time a thread actually gets to execute. However, the algorithm does ensure that a thread never executes for longer than a single time slice without being required to yield.</p>
<p>A preemtible thread that does not wish to be preempted while performing a critical operation can instruct the scheduler to temporarily treat it as a cooperative thread by calling k_sched_lock(). This prevents other threads from interfering while the critical operation is being performed.</p>
<p>Once the critical operation is complete the preemptible thread must call k_sched_unlock() to restore its normal, preemptible status.</p>
<p>If a thread calls k_sched_lock() and subsequently performs an action that makes it unready, the scheduler will switch the locking thread out and allow other threads to execute. When the locking thread again becomes the current thread, its non-preemptible status is maintained.</p>
<p>Note: Locking out the scheduler is a more efficient way for a preemptible thread to prevent preemption than changing its priority level to a negative value.</p>
<h2 id="varia"><a class="header" href="#varia">Varia</a></h2>
<p><em>What is thread sleeping?</em>
A thread can call k_sleep() to delay its processing for a specified time period. During the time the thread is sleeping the CPU is relinquished to allow other ready threads to execute. Once the specified delay has elapsed the thread becomes ready and is eligible to be scheduled once again.</p>
<p>A sleeping thread can be woken up prematurely by another thread using k_wakeup(). This technique can sometimes be used to permit the secondary thread to signal the sleeping thread that something has occured without requiring the thread to define a kernel synchronization object, such as a semaphore. Waking up a thread that is not sleeping is allowed, but has no effect. </p>
<p><em>What is busy waiting?</em>
A thread can call k_busy_wait() to perform a busy wait that delays its processing for a specified time period without relinquishing the CPU to another ready thread.</p>
<p>A busy wait is typically used instead of thread sleeping when the required delay is too short to warrant having the scheduler context switch from the current thread to another thread and then back again.</p>
<p><em>Cooperative or preemptive?</em></p>
<ul>
<li>Device drivers and other performance-critical work -&gt; cooperative threads</li>
<li>Use cooperative threads to implement mutual exclusion without the need for a kernel object, such as a mutex</li>
<li>Use preemptive threads to give priority to time-sensitive processing over less time-sensitive processing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>A couple of commands we haven't discussed in threads:</p>
<ul>
<li>k_yield: Yield the current thread. This routine causes the current thread to yield execution to another thread of the same or higher priority. If there are no other ready threads of the same or higher priority, the routine returns immediately.</li>
<li>k_wakeup: Wake up a sleeping thread. This routine prematurely wakes up thread from sleeping.</li>
<li>k_current_get: Get thread ID of the current thread. </li>
<li>k_sched_lock: A preemptible thread that does not wish to be preempted while performing a critical operation can instruct the scheduler to temporarily treat it as a cooperative thread by calling k_sched_lock(). This prevents other threads from interfering while the critical operation is being performed.</li>
<li>k_sched_unlock: Once the critical operation is complete the preemptible thread must call k_sched_unlock() to restore its normal, preemptible status.</li>
<li>k_busy_wait: A thread can call k_busy_wait() to perform a busy wait that delays its processing for a specified time period without relinquishing the CPU to another ready thread.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Scheduler configuration
| CONFIG | Description |
| --- | --- |
| CONFIG_SCHED_DUMB | The scheduler ready queue will be implemented as a simple unordered list, with very fast constant time performance for single threads and very low code size. This implementation should be selected on systems with constrained code size that will never see more than a small number (3, maybe) of runnable threads in the queue at any given time. On most platforms (that are not otherwise using the red/black tree) this results in a savings of ~2k of code size. |
| CONFIG_SCHED_SCALABLE | The scheduler ready queue will be implemented as a red/black tree. This has rather slower constant-time insertion and removal overhead, and on most platforms (that are not otherwise using the red/black tree somewhere) requires an extra ~2kb of code. The resulting behavior will scale cleanly and quickly into the many thousands of threads. Use this for applications needing many concurrent runnable threads (&gt; 20 or so). Most applications won’t need this ready queue implementation. |
| CONFIG_SCHED_MULTIQ | When selected, the scheduler ready queue will be implemented as the classic/textbook array of lists, one per priority (max 32 priorities). This corresponds to the scheduler algorithm used in Zephyr versions prior to 1.12. It incurs only a tiny code size overhead vs. the “dumb” scheduler and runs in O(1) time in almost all circumstances with very low constant factor. But it requires a fairly large RAM budget to store those list heads, and the limited features make it incompatible with features like deadline scheduling that need to sort threads more finely, and SMP affinity which need to traverse the list of threads. Typical applications with small numbers of runnable threads probably want the DUMB scheduler. |
| CONFIG_WAITQ_SCALABLE | When selected, the wait_q will be implemented with a balanced tree. Choose this if you expect to have many threads waiting on individual primitives. There is a ~2kb code size increase over CONFIG_WAITQ_DUMB (which may be shared with CONFIG_SCHED_SCALABLE) if the red/black tree is not used elsewhere in the application, and pend/unpend operations on “small” queues will be somewhat slower (though this is not generally a performance path). |
| CONFIG_WAITQ_DUMB | When selected, the wait_q will be implemented with a doubly-linked list. Choose this if you expect to have only a few threads blocked on any single IPC primitive. |</p>
<p>Thread priorities configuration
| CONFIG | Description |
| --- | --- |
| CONFIG_NUM_COOP_PRIORITIES | Number of coop priorities |
| CONFIG_NUM_PREEMPT_PRIORITIES | Number of preempt priorities |</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<p><strong>Cooperative Time Slicing</strong></p>
<p>Implement cooperative time slicing that puts out the following serial output (using <code>printk()</code>)</p>
<p><em>figure showing that thread_1, even though lower priority, doesn't yield to thread_2 (until finished)</em></p>
<p><img src="docs/scheduling//images/scheduling/serial-coop-time-slicing.png" alt="serial-coop-time-slicing" /></p>
<p><strong>Preemptive Time Slicing</strong></p>
<p>Implement Preemptive time slicing that puts out the serial (using <code>printk()</code>)</p>
<p><em>figure showing the increase in thread priority and preemption and completion of each thread</em></p>
<p><img src="docs/scheduling//images/scheduling/serial-preemptive-time-slicing.png" alt="serial-preemptive-time-slicing" /></p>
<p><strong>Time Slicing (with 3 threads)</strong></p>
<p>Implement time slicing with three threads (of equal priority)</p>
<p><em>figure showing the equal priority threads preempting each other</em></p>
<p><img src="docs/scheduling//images/scheduling/serial-time-slicing.png" alt="serial-time-slicing" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><em>What are some common debugging techniques and when to use them?</em></p>
<p>The three most common debugging techniques we'll be discussing here are:</p>
<ul>
<li>thread aware debugging (debug probe)</li>
<li>thread analysis</li>
<li>core dump</li>
</ul>
<p><em>How does thread aware debugging work?</em></p>
<p>To enable thread-aware debugging you'll need to add the line shown below to <code>zephyr/boards/arm/nucleo_f756zg/support/openocd.cfg</code></p>
<pre><code># Enable Zephyr thread awareness
$_TARGETNAME configure -rtos Zephyr
</code></pre>
<p><img src="docs/debugging//images/debugging/openocd-threads-support.png" alt="openocd-threads-support" /></p>
<p>A debug probe is special hardware which allows you to control execution of a Zephyr application running on a seperate board. Debug probes usually allow reading and writing registers and memory, and support breakpoint debugging of the Zephyr application on your host workstation using tools like GDB. </p>
<p>ST-LINK is a serial and debug adapter built into all Nucleo and Discovery boards. It provides a bridge between your computer (or other SUB host) and the embedded target processor, which can be used for debugging, flash programming, and serial communication, all over a simple USB cable.</p>
<p>It is compatible with the following host debug tools:</p>
<ul>
<li>OpenOCD Debug Host Tools</li>
<li>J-Link Debug Host Tools</li>
</ul>
<p>In this tutorial we'll be using OpenOCD.</p>
<p><em>How to use OpenOCD?</em></p>
<p>OpenOCD is available by default on ST-Link and configured as the default flash and debug tool. Flash and debug can be done as follows:</p>
<pre><code>west build -b nucleo_f756zg
west flash
</code></pre>
<pre><code>west build -b nucleo_f756zg
west debug
</code></pre>
<p><em>How does thread analysis work?</em></p>
<p>The thread analyzer module enables all the Zephyr options required to track the thread information, e.g. thread stack size usage and other runtime thread statistics.</p>
<p>The analysis is performed on demand when the application calls thread_analyzer_run() or thread_analyzer_print().</p>
<p>The output is put on the serial connection.</p>
<p><em>How does core dump work?</em></p>
<p>The core dump module enables dumping the CPU registers and memory content for offline debugging. This module is called when a fatal error is encountered, and the data is printed or stored to which backends are enabled. This core dump data can be fed into a custom made GDB server as a remote target for GDB. CPU registers, memory content and stack can be examined in the debugger.</p>
<p>This usually involves the following steps:</p>
<ol>
<li>Get the core dump log from the device depending on enabled backends.</li>
<li>Convert the core dump log into a binary format that can be parsed by the GDB server. For example, scripts/coredump/coredump_serial_log_parser.py can be used to convert the serial console log into a binary file.</li>
<li>Start the custom GDB server using the script scripts/coredump/coredump_gdbserver.py with the core dump binary log file, and the Zephyr ELF file as parameters.</li>
<li>Start the debugger corresponding to the target architecture.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="runtime-statistics"><a class="header" href="#runtime-statistics">Runtime statistics</a></h2>
<p>The analysis is performed on demand when the application calls one of the following functions:</p>
<ul>
<li>thread_analyzer_run</li>
<li>thread_analyzer_print</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="openocd"><a class="header" href="#openocd">OpenOCD</a></h2>
<h2 id="thread-analyzer"><a class="header" href="#thread-analyzer">Thread analyzer</a></h2>
<table><thead><tr><th>CONFIG</th><th>Description</th></tr></thead><tbody>
<tr><td>THREAD_ANALYZER</td><td>enable the module</td></tr>
<tr><td>THREAD_ANALYZER_USE_PRINTK</td><td>use printk for thread statistics</td></tr>
<tr><td>THREAD_ANALYZER_USE_LOG</td><td>use the logger for thread statistics</td></tr>
<tr><td>THREAD_ANALYZER_AUTO</td><td>run the thread analyzer automatically. You do not need to add any code to the application when using this option</td></tr>
<tr><td>THREAD_ANALYZER_AUTO_INTERVAL</td><td>the time for which the module sleeps between consecutive printing of thread analysis in automatic mode</td></tr>
<tr><td>THREAD_ANALYZER_AUTO_STACK_SIZE</td><td>the stack for thread analyzer automatic thread</td></tr>
<tr><td>THREAD_NAME</td><td>enable this option in the kernel to print the name of the thread instead of its ID</td></tr>
<tr><td>THREAD_RUNTIME_STATS</td><td>enable this option to print thread runtime data such as utilization (This options is automatically selected by THREAD_ANALYZER)</td></tr>
</tbody></table>
<h2 id="core-dump"><a class="header" href="#core-dump">Core dump</a></h2>
<table><thead><tr><th>CONFIG</th><th>Description</th></tr></thead><tbody>
<tr><td>DEBUG_COREDUMP</td><td>enable the module</td></tr>
<tr><td>DEBUG_COREDUMP_BACKEND_LOGGING</td><td>use log module for core dump output</td></tr>
<tr><td>DEBUG_COREDUMP_BACKEND_NULL</td><td>fallback core dump backend if other backends cannot be enabled. All output is sent to null.</td></tr>
<tr><td>DEBUG_COREDUMP_MEMORY_DUMP_MIN</td><td>only dumps the stack of the exception thread, its thread struct, and some other bare minimal data to support walking the stack in debugger. Use this only if absolute minimum of data dump is desired.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="exercise-1-multiple-threads-debugging"><a class="header" href="#exercise-1-multiple-threads-debugging">Exercise 1: Multiple threads debugging</a></h2>
<p>Using the code from the previous section (time-slicing), we'll try to see how debugging works in VSCode.</p>
<ol>
<li>in <code>multi-thread-debug</code> create folder <code>.vscode</code></li>
<li>in <code>.vscode</code> create file <code>launch.json</code></li>
<li>setup your debug config as follows inside <code>launch.json</code> (change as applicable)</li>
</ol>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;cortex-debug&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;servertype&quot;: &quot;openocd&quot;,
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
            &quot;executable&quot;: &quot;build/zephyr/zephyr.elf&quot;,
            &quot;name&quot;: &quot;zephyr STM32F756ZG&quot;,
            &quot;configFiles&quot;: [
                &quot;/Users/maksim/zephyrproject/zephyr/boards/arm/nucleo_f756zg/support/openocd.cfg&quot;
                   ],
            &quot;svdFile&quot;: &quot;STM32F756.svd&quot;
        }
    ]
}
</code></pre>
<p>The svd file can be found on the <a href="https://www.st.com/en/microcontrollers-microprocessors/stm32f756zg.html#cad-resources">STM</a> website. Add this file to your folder and mention it in <code>launch.json</code>, this way you'll be able to easily read out the different registers/peripherals/memory once you're in debug mode.</p>
<ol start="4">
<li>
<p>the svd file is necessary to be able to read registers from that specific stm processor</p>
</li>
<li>
<p>Now go to Run-&gt;Start debugging</p>
</li>
</ol>
<p><em>The first screen should look like this:</em></p>
<p><img src="docs/debugging//images/debugging/debug-starting.png" alt="debug-starting" /></p>
<p><em>If you put an interrupt in the first interrupt, the execution will again be stopped at this point</em></p>
<p><img src="docs/debugging//images/debugging/debug-breakpoint-1.png" alt="debug-breakpoint" /></p>
<p>Notice the &quot;Cortex Peripherals&quot; and &quot;Cortex Registers&quot; on the left-hand side.</p>
<h2 id="exercise-2-print-runtime-statistics"><a class="header" href="#exercise-2-print-runtime-statistics">Exercise 2: Print runtime statistics</a></h2>
<ol>
<li>
<p>Go to <code>exercises/debugging/runtime-statistics</code></p>
</li>
<li>
<p>Build &amp; Flash</p>
</li>
</ol>
<pre><code>west build -b nucleo_f756zg
west flash
</code></pre>
<ol start="3">
<li>Observe the output in the serial monitor:</li>
</ol>
<p><img src="docs/debugging//images/debugging/runtime-statistics.png" alt="runtime-statistics" /></p>
<h2 id="exercise-3-core-dump"><a class="header" href="#exercise-3-core-dump">Exercise 3: Core dump</a></h2>
<p><em>Come back to this when I understand GDB better</em></p>
<div style="break-before: page; page-break-before: always;"></div><p><em>What is an interrupt?</em></p>
<p>An interrupt service routine (ISR) is a function that executes asynchronously in response to a hardware or software interrupt. An ISR normally preempts the execution of the current thread, allowing the response to occur with very low overhead. Thread execution resumes only once all ISR work has been completed.</p>
<p>An ISR has the following key properties:</p>
<ul>
<li>An interrupt request (IRQ) signal that triggers the ISR</li>
<li>A priority level associated with the IRQ</li>
<li>An interrupt handler function that is invoked to handle the interrupt</li>
<li>An argument value that is passed to that function</li>
</ul>
<p>An interrupt descriptor table (IDT) or a vector table is used to associate a given interrupt source with a given ISR. Only a single ISR can be associated with a specific IRQ at any given time.</p>
<p>Multiple ISRs can utilize the same function to process interrupts, allowing a single function to service a device that generates multiple types of interrupts or to service multiple devices (usually of the same type). The argument value passed to an ISR's function allows the function to determine which interrupt has been signaled. </p>
<p>The kernel provides a default ISR for all unused IDT entries. This ISR generates a fatal system error if an unexpected interrupt is signaled.</p>
<p>The kernel supports interrupt nesting. This allows an ISR to be preempted in mid-execution if a higher priority interrupt is signaled. The lower priority ISR resumes execution once the higher priority ISR has completed its processing.</p>
<p>An ISR's interrupt handler function executes in the kernel's interrupt context. This context has its own dedicated stack area. The size of the interrupt context stack must be capable of handling the execution of multiple concurrent ISRs if interrupt nesting support is enabled. </p>
<p>Important: Many kernel APIs can be used only by threads, and not by ISRs. In cases where a routine may be invoked by both threads and ISRs the kernel provides the k_is_in_isr() function to allow the routine to alter its behavior depending on whether it is executing as part of a thread or as part of an ISR.</p>
<p><em>How to define a regular interrupt?</em></p>
<p>An ISR is defined at run-time by calling IRQ_CONNECT. It must then be enabled by calling irq_enable().</p>
<p>Important: IRQ_CONNECT() is not a C function and does some inline assembly magic behind the scenes. All its arguments must be known at build time. Drivers that have multiple instances may need to define per-instance config functions to configure each instance of the interrupt.</p>
<p>The following code defines and enables an ISR.</p>
<pre><code class="language-c">#define MY_DEV_IRQ  24       /* device uses IRQ 24 */
#define MY_DEV_PRIO  2       /* device uses interrupt priority 2 */
/* argument passed to my_isr(), in this case a pointer to the device */
#define MY_ISR_ARG  DEVICE_GET(my_device)
#define MY_IRQ_FLAGS 0       /* IRQ flags. Unused on non-x86 */

void my_isr(void *arg)
{
   ... /* ISR code */
}

void my_isr_installer(void)
{
   ...
   IRQ_CONNECT(MY_DEV_IRQ, MY_DEV_PRIO, my_isr, MY_ISR_ARG, MY_IRQ_FLAGS);
   irq_enable(MY_DEV_IRQ);
   ...
}
</code></pre>
<p><em>How to define a 'direct' ISR?</em></p>
<p>Regular Zephyr interrupts introduce some overhead which may be unacceptable for some low-latency use-cases. Specifically:</p>
<ul>
<li>The argument to the ISR is retrieved and passed to the ISR</li>
<li>If power management is enabled and the system was idle, all the hardware will be resumed from low-power state before the ISR is executed, which can be very time-consuming</li>
<li>Although some architectures will do this in hardware, other architectures need to switch to the interrupt stack in code</li>
<li>After the interrupt is serviced, the OS then performs some logic to potentially make a scheduling decision</li>
</ul>
<p>Zephyr supports so-called 'direct' interrupts, which are installed via IRQ_DIRECT_CONNECT. These direct interrupts have some special implementation requirements and a reduced feature set; see the definition of IRQ_DIRECT_CONNECT for details.</p>
<p>The following code demonstrates a direct ISR:</p>
<pre><code class="language-c">#define MY_DEV_IRQ  24       /* device uses IRQ 24 */
#define MY_DEV_PRIO  2       /* device uses interrupt priority 2 */
/* argument passed to my_isr(), in this case a pointer to the device */
#define MY_IRQ_FLAGS 0       /* IRQ flags. Unused on non-x86 */

ISR_DIRECT_DECLARE(my_isr)
{
   do_stuff();
   ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency */
   return 1; /* We should check if scheduling decision should be made */
}

void my_isr_installer(void)
{
   ...
   IRQ_DIRECT_CONNECT(MY_DEV_IRQ, MY_DEV_PRIO, my_isr, MY_IRQ_FLAGS);
   irq_enable(MY_DEV_IRQ);
   ...
}
</code></pre>
<p><em>How to disable interrupts?</em></p>
<p>In certain situations it may be necessary for the current thread to prevent ISRs from executing while it is performing time-sensitive or critical section operations.</p>
<p>A thread may temporarily prevent all IRQ handling in the system using an IRQ lock. This lock can be applied even when it is already in effect, so routines can use it without having to know if it is already in effect. The thread must unlock its IRQ lock the same number of times it was locked before interrupts can be once again processed by the kernel while the thread is running.</p>
<p>Important: The IRQ lock is thread-specific. if thread A locks out interrupts then performs an operation that allows thread B to run (e.g. giving a semaphore or sleeping for N milliseconds), the thread's IRQ lock no longer applies once thread A is swapped out. This means that interrupts can be processed while thread B is running unless thread B has also locked out interrupts using its own IRQ lock. </p>
<p>When thread A eventually becomes the current thread once again, the kernel re-establishes thread A's IRQ lock. This ensures thread A won't be interrupted until it has explicitly unlocked its IRQ lock.</p>
<p>Alternatively, a thread may temporarily disable a specific IRQ. The IRQ must be subsequently enabled to permit the ISR to execute.</p>
<p>Important: Disabling an IRQ prevent all threads in the system from being preempted by the associated ISR, not just the thread that disabled the IRQ.</p>
<p><em>When to use an interrupt?</em></p>
<p>Use a regular or direct ISR to perform interrupt processing that requires a very rapid response, and can be done quickly without blocking.</p>
<p>Note: Interrupt processing that is time consuming, or involves blocking, should be handed off to a thread. See <a href="https://docs.zephyrproject.org/1.9.0/kernel/other/interrupts.html#offloading-isr-work">Offloading ISR Work</a> for a description of various techniques that can be used in an application.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The following interrupt-related APIs are provided by irq.h:</p>
<table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>IRQ_CONNECT</td><td>Initialize an interrupt handler. This routine initializes an interrupt handler for an IRQ. The IRQ must be subsequently enabled before the interrupt handler begins servicing interrupts.</td></tr>
<tr><td>IRQ_DIRECT_CONNECT</td><td>Initialize a ‘direct’ interrupt handler. This routine initializes an interrupt handler for an IRQ. The IRQ must be subsequently enabled via irq_enable() before the interrupt handler begins servicing interrupts.</td></tr>
<tr><td>ISR_DIRECT_HEADER</td><td>Common tasks before executing the body of an ISR. This macro must be at the beginning of all direct interrupts and performs minimal architecture-specific tasks before the ISR itself can run. It takes no arguments and has no return value.</td></tr>
<tr><td>ISR_DIRECT_FOOTER</td><td>Common tasks before exiting the body of an ISR. This macro must be at the end of all direct interrupts and performs minimal architecture-specific tasks like EOI. It has no return value.</td></tr>
<tr><td>ISR_DIRECT_PM</td><td>Perform power management idle exit logic.</td></tr>
<tr><td>ISR_DIRECT_DECLARE</td><td>Helper macro to declare a direct interrupt service routine.</td></tr>
<tr><td>irq_lock()</td><td>Lock interrupts. This routine disables all interrupts on the CPU.</td></tr>
<tr><td>irq_unlock()</td><td>Unlock interrupts.</td></tr>
<tr><td>irq_enable()</td><td>Enable an IRQ.</td></tr>
<tr><td>irq_disable()</td><td>Disable an IRQ.</td></tr>
<tr><td>irq_is_enabled()</td><td>Get IRQ enable state.</td></tr>
</tbody></table>
<p>The following interrupt-related APIs are provided by kernel.h:
| Command | Description |
| --- | --- |
| k_is_in_isr() | Determine if code is running at interrupt level. |
| k_is_preempt_thread() | Determine if code is running in a preemptible thread. |</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="button-interrupt"><a class="header" href="#button-interrupt">Button-interrupt</a></h2>
<p>GPIO-input-interrupt</p>
<p>Configure an interrupt on a button press.</p>
<p>1 thread running continously putting out &quot;loop message&quot; every second</p>
<p>on button press: print out &quot;isr message&quot;</p>
<p><a href="https://docs.zephyrproject.org/1.9.0/kernel/other/interrupts.html">Zephyr docs</a>
<a href="https://github.com/zephyrproject-rtos/zephyr/issues/13514">Example 1</a>
<a href="https://github.com/zephyrproject-rtos/zephyr/issues/9630">Example 2</a></p>
<p>User button and LED aliases can be found in the devicetree file <code>build/zephyr/zephyr.dts</code>.</p>
<p><img src="docs/interrupts//images/interrupts/button-interrupt-alias.png" alt="button-interrupt-alias" /></p>
<p>Expected output:</p>
<p><img src="docs/interrupts//images/interrupts/button-interrupt-output.png" alt="button-interrupt-output" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands-1"><a class="header" href="#commands-1">Commands</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kconfig-1"><a class="header" href="#kconfig-1">Kconfig</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise"><a class="header" href="#exercise">Exercise</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands-2"><a class="header" href="#commands-2">Commands</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kconfig-2"><a class="header" href="#kconfig-2">Kconfig</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p><em>What is logging?</em></p>
<p>The logging API provides a common interface to process messages issued by developers. Messages are passed through a frontend and are then processed by active backends. Custom frontends and backend can be used if needed. Default configuration uses built-in frontend and UART backend.</p>
<p>Logging is highly configurable at compile time as well as at run time. Using Kconfig options logs can be gradually removed from compilation to reduce image size and execution time when logs are no longer needed. During compilation logs can be filtered out on module basis and severity level.</p>
<p>Logs can also be compiled in but filtered on run time using dedicated API. Run time filtering is indepenent for each backend and each source of log messages. Source of log messages can be a module or specific instance of the module. </p>
<p>There are four severity levels available in the system: error, warning, info and debug. For each severity level the logging API (include/logging/log.h) has a set of dedicated macros. Logger API also has macros for logging data. </p>
<p>For each level following set of macros are available (change X by level ERR, WRN, INF or DBG):</p>
<ul>
<li>LOG_X for standard printf-like messages, e.g. LOG_ERR.</li>
<li>LOG_HEXDUMP_X for dumping data, e.g. LOG_HEXDUMP_WRN.</li>
<li>LOG_INST_X for standard printf-like message associated with the particular instance, e.g. LOG_INST_INF.</li>
<li>LOG_INST_HEXDUMP_X for dumping data associated with the particular instance, e.g. LOG_HEXDUMP_INST_DBG.</li>
</ul>
<p>There are configuration categories: configurations per module and global configuration. When logging is enabled globally, it works for modules. However, modules can disable logging locally. Every module can specify its own logging level. The module must define the LOG_LEVEL macro before using the API. Unless a global override is set, the module logging level will be honored. The global override can only increase the logging level. It cannot be used to lower module logging levels that were previously higher. It is also possible to globally limit logs by providing maximal severity level present in the system, where maximal means lowest severity (e.g. if maximal level in the system is set to info, it means that errors, warnings and info levels are present but debug messages are excluded).</p>
<p>Each module which is using the logging must specify its unique name and register itself to the logging. If module consists of more than one file, registration is performed in one file but each file must define a module name.</p>
<p>Logger's default frontend is designed to be thread-safe and minimizes time needed to log the message. Time consuming operations like string formatting or access to the transport are not performed by default when logging API is called. When logging API is called a message is created and added to the list. Dedicated, configurable buffer for pool or log messages is used. There are 2 types of messages: standard and hexdump. Each message contains source ID (module or instance ID and domain ID which might be used for multiprocessor systems), timestamp and severity level. Standard message contains pointer to the string and arguments. Hexdump message contains copied data and string. </p>
<p><em>How to use logging?</em></p>
<p>In order to use logging in the module, a unique name of a module must be specified and module must be registered using LOG_MODULE_REGISTER. Optionally, a compile time log level for the module can be specified as the second parameter. Default log level (CONFIG_LOG_DEFAULT_LEVEL) is used if custom log level is not provided.</p>
<pre><code class="language-c">#include &lt;logging/log.h&gt;
LOG_MODULE_REGISTER(foo, CONFIG_FOO_LOG_LEVEL);
</code></pre>
<p>If the module consists of multiple files, then LOG_MODULE_REGISTER should appear in exactly one of them. All the other files should use LOG_MODULE_DECLARE to declare its membership in the module. Optionally, a compile time log level for the module can be specified as the second parameter. Default log level (CONFIG_LOG_DEFAULT_LEVEL) is used if custom log level is not provided.</p>
<pre><code class="language-c">#include &lt;logging/log.h&gt;
/* In all files comprising the module but one */
LOG_MODULE_DECLARE(foo, CONFIG_FOO_LOG_LEVEL);
</code></pre>
<p>In order to use logging API in a function implemented in a header file LOG_MODULE_DECLARE macro must be used in the function body before logging API is called. Optionally, a compile time log level for the module can be specified as the second parameter. Default log level (CONFIG_LOG_LEVEL_DEFAULT_LEVEL) is used if custom log level is not provided.</p>
<pre><code class="language-c">#include &lt;logging/log.h&gt;

static inline void foo(void)
{
     LOG_MODULE_DECLARE(foo, CONFIG_FOO_LOG_LEVEL);

     LOG_INF(&quot;foo&quot;);
}
</code></pre>
<p>Dedicated Kconfig template (subsys/logging/Kconfig.template.log_config) can be used to create local log level configuration.</p>
<p>Example below presents usage of the template. As a result CONFIG_FOO_LOG_LEVEL will be generated:</p>
<pre><code>module = FOO
module-str = foo
source &quot;subsys/logging/Kconfig.template.log_config&quot;
</code></pre>
<p>Controlling the logging</p>
<p>Logging can be controlled using API defined in include/logging/log_ctrl.h. Logger must be initialized before it can be used. Optionally, user can provide a function which returns time; if not, k_cycle_get_32 is used. log_process() function is used to trigger processing of one log message (if pending). Function returns true if there is more messages pending. </p>
<p>Following snippet shows how logging can be processed in simple forever loop.</p>
<pre><code class="language-c">#include &lt;log_ctrl.h&gt;

void main(void)
{
     log_init();

     while (1) {
             if (log_process() == false) {
                     /* sleep */
             }
     }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>X: ERR, WRN, INF or DGB </p>
<table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>LOG_X</td><td>Writes an X level message to the log</td></tr>
<tr><td>LOG_PRINTK</td><td>Unconditionally print raw log message</td></tr>
<tr><td>LOG_INST_X</td><td>Writes an X level message associated with the instance to the log</td></tr>
<tr><td>LOG_HEXDUMP_X</td><td>Writes an X level hexdump message to the log</td></tr>
<tr><td>LOG_INST_HEXDUMP_X</td><td>Writes an X level hexdump message associated with the instance to the log</td></tr>
<tr><td>LOG_MODULE_REGISTER</td><td>Create module-specific state and register the module with Logger. This macro normally must be used after including &lt;logging/log.h&gt; to complete the initialization of the module.</td></tr>
<tr><td>LOG_MODULE_DECLARE</td><td>Macro for declaring a log module (not registering it).</td></tr>
<tr><td>LOG_LEVEL_SET</td><td>Macro for setting log level in the file or function where instance logging API is used.</td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><p>Mode of operations:
| Kconfig | Description |
| --- | --- |
| CONFIG_LOG | Deferred mode |
| CONFIG_LOG_MODE_DEFERRED | Deferred mode |
| CONFIG_LOG2_MODE_DEFERRED | Deferred mode v2 |
| CONFIG_LOG_MODE_IMMEDIATE | Immediate (synchronous) mode |
| CONFIG_LOG2_MODE_IMMEDIATE | Immediate (synchronous) mode v2 |
| CONFIG_LOG_MODE_MINIMAL | Minimal footprint mode |</p>
<p>Filtering options:
| Kconfig | Description |
| --- | --- |
| CONFIG_LOG_RUNTIME_FILTERING | Enables runtime reconfiguration of the filtering. |
| CONFIG_LOG_DEFAULT_LEVEL | Default level, sets the logging level used by modules that are not setting their own logging level. |
| CONFIG_LOG_OVERRIDE_LEVEL | It overrides module logging level when it is not set or set lower than the override value. |
| CONFIG_LOG_MAX_LEVEL | Maximal (lowest severity) level which is compiled in. |</p>
<p>Processing options:
| Kconfig | Description |
| --- | --- |
| CONFIG_LOG_PRINTK | Redirect printk calls to the logging |
| CONFIG_LOG_BUFFER_SIZE | Number of bytes dedicated for the message pool. Single message capable of storing standard log with up to 3 arguments or hexdump message with 12 bytes of data take 32 bytes. In v2 it indicates buffer size dedicated for circular packet buffer. |</p>
<p>Formatting options:
| Kconfig | Description |
| --- | --- |
| CONFIG_LOG_FUNC_NAME_PREFIX_ERR | Prepend standard ERROR log messages with function name. Hexdump messages are not prepended. |
| CONFIG_LOG_FUNC_NAME_PREFIX_WRN | Prepend standard WARNING log messages with function name. Hexdump messages are not prepended. |
| CONFIG_LOG_FUNC_NAME_PREFIX_INF | Prepend standard INFO log messages with function name. Hexdump messages are not prepended. |
| CONFIG_LOG_FUNC_NAME_PREFIX_DBG | Prepend standard DEBUG log messages with function name. Hexdump messages are not prepended. |
| CONFIG_LOG_BACKEND_SHOW_COLOR | Enables coloring of errors (red) and warnings (yellow). |
| CONFIG_LOG_BACKEND_FORMAT_TIMESTAMP | If enabled timestamp is formatted to hh:mm:ss:mmm,uuu. Otherwise is printed in raw format. |</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<p>If you have no experience with network programming, I'd recommend first working through <a href="https://www.youtube.com/playlist?list=PLfIJKC1ud8ggZKVtytWAlOS63vifF5iJC">this</a> course. The Lwip stack is very similar to the way the Zephyr Network stack works.</p>
<h2 id="bsd-sockets"><a class="header" href="#bsd-sockets">BSD Sockets</a></h2>
<p>Zephyr offers an implementation of a subset of the BSD Sockets API. This API allows to port existing simple networking applications to Zephyr.</p>
<p>Here are the key requirements and concepts which governed BSD Sockets compatible API implementation for Zephyr.</p>
<ul>
<li>Has minimal overhead, similar to the requirement for other Zephyr subsystems.</li>
<li>Is namespaced by default, to avoid conflicts with well-known names like <code>close()</code>, which may be part of libc or other POSIX compatibility libraries. If enabled by <code>CONFIG_NET_SOCKETS_POSIX_NAMES</code>, it will also expose native POSIX names. </li>
</ul>
<p>BSD Sockets compatible API is enabled using CONFIG_NET_SOCKETS config option and implements the following operations:</p>
<ul>
<li>socket()</li>
<li>close()</li>
<li>recv()</li>
<li>recvfrom()</li>
<li>send()</li>
<li>sendto()</li>
<li>connect()</li>
<li>bind()</li>
<li>listen()</li>
<li>accept()</li>
<li>fcntl()</li>
<li>getsockopt()</li>
<li>setsockopt()</li>
<li>poll()</li>
<li>select()</li>
<li>getaddrinfo()</li>
<li>getnameinfo()</li>
</ul>
<p>Based on the namespacing requirements above, these operations are by default exposed as functions with <code>zsock_</code> prefix, e.g. <code>zsock_socket()</code>,... If the config option CONFIG_NET_SOCKETS_POSIX_NAMES is defined, all the functions will be also exposed as aliases without the prefix. This includes the functions like <code>close()</code> and <code>fcntl()</code> (which may conflict with functions in libc or other libraries, for example, with the filesystem libraries).</p>
<p>Another entailment of the design requirements above is that the Zephyr API aggressively employs the short-read/short-write property of the POSIX API whenever possible (to minimize complexity and overheads). POSIX allows for calls like <code>recv()</code> and <code>send()</code> to actually process (receive or send) less data than requested by the user (on SOCK_STREAM type sockets). For example, a call recv(sock, 1000, 0) may return 100, meaning that only 100 bytes were read (short read), and the application needs to retry call(s) to receive the remaining 900 bytes.</p>
<p>The BSD Sockets API uses file descriptors to represent sockets. File descriptors are small integers, consecutively assigned from zero, shared among sockets, files, special devices (liek stdin/stdout), etc. Internally, there is a table mapping file descriptors to internal object pointers. The file descriptor table is used by the BSD Sockets API even if the rest of the POSIX subsystem (filesystem, stdin/stdout) is not enabled. </p>
<div style="break-before: page; page-break-before: always;"></div><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>zsock_socket</td><td></td></tr>
<tr><td>zsock_socketpair</td><td></td></tr>
<tr><td>zsock_close</td><td></td></tr>
<tr><td>zsock_shutdown</td><td></td></tr>
<tr><td>zsock_bind</td><td></td></tr>
<tr><td>zsock_connect</td><td></td></tr>
<tr><td>zsock_listen</td><td></td></tr>
<tr><td>zsock_accept</td><td></td></tr>
<tr><td>zsock_sendto</td><td></td></tr>
<tr><td>zsock_send</td><td></td></tr>
<tr><td>zsock_sendmsg</td><td></td></tr>
<tr><td>zsock_recvfrom</td><td></td></tr>
<tr><td>zsock_recv</td><td></td></tr>
<tr><td>zsock_fcntl</td><td></td></tr>
<tr><td>zsock_poll</td><td></td></tr>
</tbody></table>
<p>see <a href="https://docs.zephyrproject.org/latest/reference/networking/sockets.html#id1">link</a></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>https://docs.zephyrproject.org/1.9.0/subsystems/networking/networking.html</p>
<p>https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_TCP/TCP_Networking_Tutorial_TCP_Client_and_Server.html</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>What is a timer?</em></p>
<p>A timer is a kernel object that measures the passage of time using the kernel's system clock. When a timer's specified time limit is reached it can perform an application-defined action, or it can simply record the expiration and wait for the application to read its status.</p>
<p>Any number of timer can be defined (limited only by available RAM). Each timer is referenced by its memory address.</p>
<p>A timer has the following key priorities:</p>
<ul>
<li>A duration specifying the time interval before the timer expires for the first time. This is a k_timeout_t value that may be initialized via different units.</li>
<li>A period specifying the time interval between all timer expirations after the first one, also a k_timeout_t. It must be non-negative. A period of K_NO_WAIT (i.e. zero) or K_FOREVER means that the times is a one shot timer that stops after a single expiration. (For example then, if a timer is started with a duration of 200 and a period of 75, it will first expire after 200ms and then every 75ms after that.)</li>
<li>An expiry function that is executed each time the timer expires. The function is executed by the system clock interrupt handler. If no expiry function is required a NULL function can be specified.</li>
<li>A stop function that is executed if the timer is stopped prematurely while running. The function is executed by the thread that stops the timer. If no stop function is required a NULL function can be specified.</li>
<li>A status value that indicates how many times the timer has expired since the status value was last read. </li>
</ul>
<p>A timer must be initialized before it can be used. This specifies its expiry function and stop function values, sets the timer's status to zero, and puts the timer into the stopped state.</p>
<p>A timer is started by specifying a duration and a period. The timer's status is reset to zero, then the timer enters the running state and begins counting down towards expiry.</p>
<p>Note that the timer's duration and period parameters specify minimum delays that will elapse. Because of internal system timer precision (and potentially runtime interactions like interrupt delay) it is possible that more time may have passed as measured by reads from the relevant system time APIs. But at least this much time is guaranteed to have elapsed.</p>
<p>When a running timer expires its status is incremented and the timer executes its expiry function, if one exists; if a thread is waiting on the timer, it is unblocked. If the timer's period is zero the timer enters the stopped state; otherwise the timer restarts with a new duration equal to its period. </p>
<p>A running timer can be stopped in mid-countdown, if desired. The timer's status is left unchanged, then the timer enters the stopped state and executes its stop function, if one exists. If a thread is waiting on the timer, it is unblocked. Attempting to stop a non-running timer is permitted, but has no effect on the timer since it is already stopped. </p>
<p>A running timer can be restarted in mid-countdown, if desired. The timer's status is reset to zero, then the timer begins counting down using the new duration and period values specified by the caller. If a thread is waiting on the timer, it continues waiting. </p>
<p>A timer's status can be read directly at any time to determine how many times the timer has expired since its status was last read. Reading a timer's status resets its value to zero. The amount of time remaining before a timer expires can also be read; a value of zero indicates that the timer has stopped.</p>
<p>A thread may read a timer's status indirectly by synchronizing with the timer. This blocks the thread until the timer's status is non-zero (indicating that it has expired at least once) or the timer is stopped; if the timer status is already non-zero or the timer is already stopped the thread continues with waiting. The synchronization operation returns the timer's status and resets it to zero.</p>
<p>Note: Only a single user should examine the status of any given timer, since reading the status (directly or indirectly) changes its value. Similarly, only a single thread at a time should synchronize with a given timer. ISRs are not permitted to synchronize with timers, since ISRs are not allowed to block. </p>
<p><em>How to define a timer?</em></p>
<p>A timer is defined using a variable of type k_timer. It must then be initialized by calling k_timer_init().</p>
<p>The following code defines and initializes a timer.</p>
<pre><code class="language-c">struct k_timer my_timer;
extern void my_expiry_function(struct k_timer *timer_id);

k_timer_init(&amp;my_timer, my_expiry_function, NULL);
</code></pre>
<p>Alternatively, a timer can be defined and initialized at compile time by calling K_TIMER_DEFINE.</p>
<p>The following code has the same effect as the code segment above.</p>
<pre><code class="language-c">K_TIMER_DEFINE(my_timer, my_expiry_function, NULL);
</code></pre>
<p>The following code uses a timer to perform a non-trivial action on a periodic basis. Since the required work cannot be done at interrupt level, the timer's expiry function submits a work item to the system workqueue, whose thread performs the work.</p>
<pre><code class="language-c">void my_work_handler(struct k_work *work)
{
    /* do the processing that needs to be done periodically */
    ...
}

K_WORK_DEFINE(my_work, my_work_handler);

void my_timer_handler(struct k_timer *dummy)
{
    k_work_submit(&amp;my_work);
}

K_TIMER_DEFINE(my_timer, my_timer_handler, NULL);

...

/* start periodic timer that expires once every second */
k_timer_start(&amp;my_timer, K_SECONDS(1), K_SECONDS(1));
</code></pre>
<p>The following code reads a timer's status directly to determine if the timer has expired or not.</p>
<pre><code class="language-c">K_TIMER_DEFINE(my_status_timer, NULL, NULL);

...

/* start one shot timer that expires after 200 ms */
k_timer_start(&amp;my_status_timer, K_MSEC(200), K_NO_WAIT);

/* do work */
...

/* check timer status */
if (k_timer_status_get(&amp;my_status_timer) &gt; 0) {
    /* timer has expired */
} else if (k_timer_remaining_get(&amp;my_status_timer) == 0) {
    /* timer was stopped (by someone else) before expiring */
} else {
    /* timer is still running */
}
</code></pre>
<p>The following code performs timer status synchronization to allow a thread to do useful work while ensuring that a pair of protocol operations are seperated by the specified time interval.</p>
<pre><code class="language-c">K_TIMER_DEFINE(my_sync_timer, NULL, NULL);

...

/* do first protocol operation */
...

/* start one shot timer that expires after 500 ms */
k_timer_start(&amp;my_sync_timer, K_MSEC(500), K_NO_WAIT);

/* do other work */
...

/* ensure timer has expired (waiting for expiry, if necessary) */
k_timer_status_sync(&amp;my_sync_timer);

/* do second protocol operation */
...
</code></pre>
<p><em>When to use a timer?</em></p>
<p>Use a timer to initiate an asynchronous operation after a specified amount of time.</p>
<p>Use a timer to determine whether or not a specified amount of time has elapsed. In particular, timers should be used when higher precision and/or unit control is required than that afforded by the simpler k_sleep() and k_usleep() calls.</p>
<p>Use a timer to perform other work while carrying out operations involving time limits.</p>
<p>Note: If a thread needs to measure the time required to perform an operation it can read the system clock or the hardware clock directly, rather than using a timer. </p>
<div style="break-before: page; page-break-before: always;"></div><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>k_timer_init</td><td>Initialize a timer. This routine initializes a timer, prior to its first use.</td></tr>
<tr><td>k_timer_start</td><td>Start a timer. This routine starts a timer, and resets its status to zero. The timer begins counting down using the specified duration and period values.</td></tr>
<tr><td>k_timer_stop</td><td>Stop a timer. This routine stops a running timer prematurely. The timer’s stop function, if one exists, is invoked by the caller.</td></tr>
<tr><td>k_timer_status_get</td><td>Read timer status. This routine reads the timer’s status, which indicates the number of times it has expired since its status was last read.</td></tr>
<tr><td>k_timer_status_sync</td><td>Synchronize thread to timer expiration. This routine blocks the calling thread until the timer’s status is non-zero (indicating that it has expired at least once since it was last examined) or the timer is stopped. If the timer status is already non-zero, or the timer is already stopped, the caller continues without waiting.</td></tr>
<tr><td>k_timer_expires_ticks</td><td>Get next expiration time of a timer, in system ticks.</td></tr>
<tr><td>k_timer_remaining_ticks</td><td>Get time remaining before a timer next expires, in system ticks.</td></tr>
<tr><td>k_timer_remaining_get</td><td>Get time remaining before a timer next expires.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><p>None</p>
<div style="break-before: page; page-break-before: always;"></div><p>Define a timer that will print a message after 2 s and then every second.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
